<!DOCTYPE html> <html lang="en"> <head> <meta http-equiv="Content-Type" content="text/html; charset=UTF-8"> <meta charset="utf-8"> <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no"> <meta http-equiv="X-UA-Compatible" content="IE=edge"> <title> Computer Organization Note (Part 3 of 4) | Yuzhuo Tian </title> <meta name="author" content="Yuzhuo Tian"> <meta name="description" content="Contains content about CPU design."> <meta name="keywords" content="jekyll, jekyll-theme, academic-website, portfolio-website"> <link rel="stylesheet" href="/assets/css/bootstrap.min.css?a4b3f509e79c54a512b890d73235ef04"> <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/mdbootstrap@4.20.0/css/mdb.min.css" integrity="sha256-jpjYvU3G3N6nrrBwXJoVEYI/0zw8htfFnhT9ljN3JJw=" crossorigin="anonymous"> <link defer rel="stylesheet" href="/assets/css/academicons.min.css?f0b7046b84e425c55f3463ac249818f5"> <link defer rel="stylesheet" href="/assets/css/scholar-icons.css?62b2ac103a88034e6882a5be5f3e2772"> <link defer rel="stylesheet" type="text/css" href="https://fonts.googleapis.com/css?family=Roboto:300,400,500,700|Roboto+Slab:100,300,400,500,700|Material+Icons&amp;display=swap"> <link defer rel="stylesheet" href="/assets/css/jekyll-pygments-themes-github.css?591dab5a4e56573bf4ef7fd332894c99" media="" id="highlight_theme_light"> <link rel="shortcut icon" href="/assets/img/favicon.ico?f566e11424fb8bc11d484dac03de3f7f"> <link rel="stylesheet" href="/assets/css/main.css?d41d8cd98f00b204e9800998ecf8427e"> <link rel="canonical" href="https://sqrtyz.github.io/blog/2024/CO-NOTE-3/"> <script src="/assets/js/theme.js?a81d82887dd692e91686b43de4542f18"></script> <link defer rel="stylesheet" href="/assets/css/jekyll-pygments-themes-native.css?5847e5ed4a4568527aa6cfab446049ca" media="none" id="highlight_theme_dark"> <script>
    initTheme();
  </script> </head> <body class="fixed-top-nav "> <header> <nav id="navbar" class="navbar navbar-light navbar-expand-sm fixed-top" role="navigation"> <div class="container"> <a class="navbar-brand title font-weight-lighter" href="/"> <span class="font-weight-bold">Yuzhuo</span> Tian </a> <button class="navbar-toggler collapsed ml-auto" type="button" data-toggle="collapse" data-target="#navbarNav" aria-controls="navbarNav" aria-expanded="false" aria-label="Toggle navigation"> <span class="sr-only">Toggle navigation</span> <span class="icon-bar top-bar"></span> <span class="icon-bar middle-bar"></span> <span class="icon-bar bottom-bar"></span> </button> <div class="collapse navbar-collapse text-right" id="navbarNav"> <ul class="navbar-nav ml-auto flex-nowrap"> <li class="nav-item "> <a class="nav-link" href="/">about </a> </li> <li class="nav-item active"> <a class="nav-link" href="/blog/">blog </a> </li> <li class="nav-item "> <a class="nav-link" href="/publications/">publications </a> </li> <li class="nav-item "> <a class="nav-link" href="/cv/">cv </a> </li> <li class="nav-item"> <button id="search-toggle" title="Search" onclick="openSearchModal()"> <span class="nav-link">ctrl k <i class="ti ti-search"></i></span> </button> </li> <li class="toggle-container"> <button id="light-toggle" title="Change theme"> <i class="ti ti-sun-moon" id="light-toggle-system"></i> <i class="ti ti-moon-filled" id="light-toggle-dark"></i> <i class="ti ti-sun-filled" id="light-toggle-light"></i> </button> </li> </ul> </div> </div> </nav> <progress id="progress" value="0"> <div class="progress-container"> <span class="progress-bar"></span> </div> </progress> </header> <div class="container mt-5" role="main"> <div class="post"> <header class="post-header"> <h1 class="post-title">Computer Organization Note (Part 3 of 4)</h1> <p class="post-meta"> Created on January 01, 2024 </p> <p class="post-tags"> <a href="/blog/2024"> <i class="fa-solid fa-calendar fa-sm"></i> 2024 </a>   ·   <a href="/blog/tag/hardware"> <i class="fa-solid fa-hashtag fa-sm"></i> Hardware</a>   ·   <a href="/blog/category/coursenotes"> <i class="fa-solid fa-tag fa-sm"></i> CourseNotes</a> </p> </header> <article class="post-content"> <div id="markdown-content"> <h2 id="chapter-4-1-processor-single-cycle-ver">Chapter 4-1 Processor: Single Cycle Ver</h2> <h3 id="introduction">Introduction</h3> <p>基本的思路是，在之前我们学习了 C -&gt; Assembly Language -&gt; Machine Code 的过程。而 CPU 的工作就是执行机器码。例如，对于指令 <code class="language-plaintext highlighter-rouge">add x10, x11, x12</code>，我们要用 CPU 完成以下工作：</p> <ul> <li> <p>读取 <code class="language-plaintext highlighter-rouge">x11</code> 和 <code class="language-plaintext highlighter-rouge">x12</code></p> </li> <li> <p>计算两者的和</p> </li> <li> <p>把和写到 <code class="language-plaintext highlighter-rouge">x10</code> 中</p> </li> </ul> <p>在本门课程中，我们主要关心以下指令：</p> <table> <thead> <tr> <th>Inst Type</th> <th>Inst</th> </tr> </thead> <tbody> <tr> <td>R-Type</td> <td>Arithmetic (<code class="language-plaintext highlighter-rouge">add</code>, <code class="language-plaintext highlighter-rouge">sub</code>, <code class="language-plaintext highlighter-rouge">and</code>, …)</td> </tr> <tr> <td>I-Type</td> <td>Load Register (<code class="language-plaintext highlighter-rouge">ld</code>)</td> </tr> <tr> <td>S-Type</td> <td>Store Register (<code class="language-plaintext highlighter-rouge">sd</code>)</td> </tr> <tr> <td>SB-Type</td> <td>Branch Jump (<code class="language-plaintext highlighter-rouge">beq</code>)</td> </tr> <tr> <td>UJ-Type</td> <td>Unconditional Jump (<code class="language-plaintext highlighter-rouge">jal</code>)</td> </tr> </tbody> </table> <h3 id="the-entire-processor">The Entire Processor</h3> <p><img src="/assets/img/blog_post/co/cod-54.png" alt="cod-54" width="50%"></p> <p>其实整个一节的关键信息就这一幅图。其中的一些关键点：</p> <ul> <li> <p>PC 表示当前的指令位置。</p> </li> <li> <p>Instruction Memory 存放的是系列指令，可以理解为内存中的 Text 段。</p> </li> <li> <p>Registers 寄存器。RISC-V 具有 32 个各 64 位的寄存器。</p> </li> <li> <p>Data Memory 存放的是各种数据，可理解为内存中的 Data 段。</p> </li> </ul> <p>黑色的部分对应 CPU 的 Data Path，蓝色的部分对应 CPU 的 Control Unit。可以看到，Control 部分由 Opcode 全权完成。</p> <p>接下来根据指令类型的不同，详细分析数据的走向。注意下面的图片仅作示意，不一定严谨。有的图片还有订正。</p> <h3 id="processor-datapath-details">Processor Datapath Details</h3> <h4 id="1-r-type">1. R-Type</h4> <p><img src="/assets/img/blog_post/co/cod-55.png" alt="cod-55" width="50%"></p> <h4 id="2-i-type-only-ld">2. I-Type (ONLY ld)</h4> <p><img src="/assets/img/blog_post/co/cod-58.png" alt="cod-58" width="50%"></p> <p><strong>[ATTENTION]</strong> 图片有点问题，指令中的 <code class="language-plaintext highlighter-rouge">rs1</code> 连到寄存器的 <code class="language-plaintext highlighter-rouge">rs2</code> 上了，应当连到 <code class="language-plaintext highlighter-rouge">rs1</code> 上。</p> <ul> <li>其中 <code class="language-plaintext highlighter-rouge">20{inst[31]}</code> 是在做符号位拓展，因为本来也支持立即数为负的情况。</li> </ul> <h4 id="3-s-type-only-sd">3. S-Type (ONLY sd)</h4> <p><img src="/assets/img/blog_post/co/cod-57.png" alt="cod-57" width="50%"></p> <h4 id="4-sb-type-only-beq">4. SB-Type (ONLY beq)</h4> <p><img src="/assets/img/blog_post/co/cod-56.png" alt="cod-56" width="50%"></p> <ul> <li>这里 ALU 执行的是 sub 运算，然后根据 <code class="language-plaintext highlighter-rouge">zero</code> 判断是否相等。如果 <code class="language-plaintext highlighter-rouge">zero</code> 为 1（beq 条件满足）且 <code class="language-plaintext highlighter-rouge">branch</code> 为 1（本条指令为 beq），那么就开跳。</li> </ul> <h4 id="5-uj-type-only-jal">5. UJ-Type (ONLY jal)</h4> <p><img src="/assets/img/blog_post/co/cod-59.png" alt="cod-59" width="50%"></p> <ul> <li>注意是 PC+4 进入到 <code class="language-plaintext highlighter-rouge">Write Data</code> 中。</li> </ul> <h3 id="controller">Controller</h3> <p>回顾一开始整个单周期 CPU 的图片，我们再贴一次：</p> <p><img src="/assets/img/blog_post/co/cod-54.png" alt="cod-54" width="50%"></p> <p>根据 Opcode，我们需要通过 Controller 给出以下 8 个具体信号：</p> <ul> <li>R/W - RegWrite (0/1): 控制是否向寄存器里面写入。</li> <li>R/W - MemRead (0/1): 控制是否从内存读取。</li> <li>R/W - MemWrite (0/1): 控制是否向内存中写入数据。</li> <li>MUX - ALUSrc (0/1): 控制 ALU 下侧的数据来源，0 表示 rs2，1 表示 ImmGen。</li> <li>MUX - Branch (0/1): 表示当前指令是否为 branch jumping，用于控制下一个 PC。0 表示不为 branch，1 表示为 branch。结合 Zero 进行食用。</li> <li>MUX - Jump (0/1): 控制 PC 是否进行无条件跳转。例如当前指令为 <code class="language-plaintext highlighter-rouge">jal</code> 时该值为 1。</li> <li>MUX - MemtoReg (2 bits): 控制返回到 write address 中的数据来源。分别表示 PC+4，内存读出数据，ALU 计算结果。</li> <li>ALU op (2 bits): 用于指导 ALU 进行的运算类型。后续会过一次 ALU Control。</li> </ul> <p><strong>接下来专门讲一下 ALU 的具体控制</strong>。可以看到，ALU 的控制可以视为「两级」：</p> <ul> <li> <p>第一级：根据 ALU op 将不同类别的指令进行基础区分。</p> </li> <li> <p>第二级：相同 ALU op 的基础上，再根据 funct3 和 funct7 对不同运算的指令进行区分（这部分 funct 从上图的 <code class="language-plaintext highlighter-rouge">inst[30,14:12]</code> 线钻进去）。</p> </li> </ul> <p><img src="/assets/img/blog_post/co/cod-60.png" alt="cod-60" width="50%"></p> <p>或许可以回顾一下 ALU：</p> <p><img src="/assets/img/blog_post/co/cod-9.png" alt="cod-9" width="50%"></p> <h2 id="chapter-4-2-processor-pipeline-ver">Chapter 4-2 Processor: Pipeline Ver</h2> <h3 id="intro">Intro</h3> <ul> <li> <p>不同指令耗时不一</p> <p>例如在下图中，假设各部分的操作时长为：Memory Access, 200ps; ALU, 200ps; RegFile Access, 100ps。</p> <p>那么执行一次 <code class="language-plaintext highlighter-rouge">ld</code> 指令耗时为 800ps。执行一次 <code class="language-plaintext highlighter-rouge">sd</code> 指令耗时为 700ps。</p> <p><img src="/assets/img/blog_post/co/cod-61.png" alt="cod-61" width="80%"></p> </li> <li> <p>Pipelining Analogy</p> <p>一种优化思路是从瓶颈（例如 <code class="language-plaintext highlighter-rouge">ld</code>）下手。然而我们还有另外一种优化思路——将【单周期 CPU】改为【流水线 CPU】。所谓流水线，可以参照这幅图：</p> <p><img src="/assets/img/blog_post/co/cod-62.png" alt="cod-62" width="70%"></p> <p>对应到 CPU 中，我们可以尝试把其分为若干个区域（或步骤），让每个区域同时工作，实现整体的流水线工作。</p> </li> </ul> <h3 id="risc-v-pipeline-intro">RISC-V Pipeline Intro</h3> <p>RISC-V CPU 可以划分为以下五个阶段：</p> <ol> <li> <strong>IF</strong>: Instruction fetch from memory</li> <li> <strong>ID</strong>: Instruction decode &amp; read from register</li> <li> <strong>EX</strong>: Execute operation or calculate address (ALU Part)</li> <li> <strong>MEM</strong>: Access memory operand</li> <li> <strong>WB</strong>: Write result back to register</li> </ol> <p>然后，一种简单的思路就是，我让五个阶段「流水线式」地工作，下图地两张图生动地说明了这一原理：</p> <p><img src="/assets/img/blog_post/co/cod-63.png" alt="cod-63" width="90%"></p> <p><img src="/assets/img/blog_post/co/cod-64.png" alt="cod-64" width="90%"></p> <p>理想情况下，这一转变将让 CPU 提速 5 倍（因为有 5 个阶段，当然实际不会到达这个数值，看上图的下半部分可以理解；而且后面还有各种 hazards）。</p> <h3 id="hazards">Hazards</h3> <p>中文意为「冒险」，表示流水线 CPU 实现中可能遇到的各种容易出问题的情况。</p> <h4 id="1-structure-hazard">1. Structure Hazard</h4> <p>可以想象，如果 data memory 和 instruction memory 是在同一部分的话，在 pipeline 的情形下，有的周期会调用同一块内存，这将产生冲突。</p> <p>好在 RISC-V 的设计将 data memory 和 instruction memory 分隔开，所以我们几乎不用考虑 Structure Hazard。</p> <h4 id="2-data-hazard">2. Data Hazard</h4> <ul> <li> <p>Problem: Data Hazard</p> <p>有的时候执行某一个指令，要求前一个指令完成数据写入。考虑这样的两个相邻指令：</p> <pre><code class="language-ass">  add x19, x0, x1
  sub x2, x19, x3
</code></pre> <p><img src="/assets/img/blog_post/co/cod-65.png" alt="cod-65" width="90%"></p> <p>add 指令的 WB 必须要在 sub 指令的 ID 之前执行（原因显然），所以两个指令之间无法再「紧密地排列在流水线上」，中间需要隔两个 bubble。</p> <p>【OBSERVATION】观察上上张图，WB 的写 reg 是在上半 cycle，ID 的读 reg 是在下半 cycle。这种设计的缘由其实在这里有所体现。</p> </li> <li> <p>Solution: Forwarding</p> <p>解决这种情况的一种方案是 Forwarding。大概思路是有的时候我们不必等待一个数据被写入 reg，然后才再次使用；而是可以直接用某种 extra connection 来直接高效地使用。下图演示了 Forwarding 的解决方案。</p> <p><img src="/assets/img/blog_post/co/cod-66.png" alt="cod-66" width="90%"></p> <p>然而，并非所有 Data Hazard 都可以用 Forwarding 解决。考虑这样的情形：</p> <p><img src="/assets/img/blog_post/co/cod-67.png" alt="cod-67" width="90%"></p> <p>显然 sub 已经没办法再提前一个 cycle 了，不然 sub 的 EX 和 ld 的 MEM 将处在同一 cycle，而 sub 的 EX 需要 ld 的 MEM 提供前提数据。</p> <p>不过，也可以通过修改汇编代码来规避这一问题——</p> <p><img src="/assets/img/blog_post/co/cod-68.png" alt="cod-68" width="90%"></p> </li> </ul> <h4 id="3-control-hazard">3. Control Hazard</h4> <ul> <li> <p>Problem: Stall on Branch</p> <p><img src="/assets/img/blog_post/co/cod-69.png" alt="cod-69" width="80%"></p> <p>类似于这种 Branch Jumping 带来的停顿。上图有点问题，按理来说应当是两行 bubble。</p> </li> <li> <p>Solution: Branch Prediction</p> <p>字面意思，提前预测 branch 的结果。一般可以分为静态预测 (Static branch prediction) 和动态预测 (Dynamic branch prediction)。</p> <p>静态预测一般是在软件层面上，根据普遍的 branch 选择结果进行预测。</p> <p>动态预测一般是在硬件层面上，比如可以基于上一次 branch 的选择结果进行预测（考虑循环的情形，这种预测应当是成功率较高的）。</p> </li> </ul> <h3 id="risc-v-pipelined-datapath">RISC-V Pipelined Datapath</h3> <p>在解决这一系列 hazards 之前，我们需要对 CPU 的结构进行修改。总的图形如下：</p> <p><img src="/assets/img/blog_post/co/cod-70.png" alt="cod-70" width="100%"></p> <ul> <li> <p>四个中间寄存器：<code class="language-plaintext highlighter-rouge">IF/ID</code>，<code class="language-plaintext highlighter-rouge">ID/EX</code>，<code class="language-plaintext highlighter-rouge">EX/MEM</code> 以及 <code class="language-plaintext highlighter-rouge">MEM/WB</code>。</p> <p>字面意思表明了其所处位置。引入寄存器的目的是显而易见的，是为了使得在流水线上，每个周期的指令依然能正确读取数据。比如观察 Reg 的 Write Data 输入，肯定得引入 <code class="language-plaintext highlighter-rouge">MEM/WB</code> 的值，而不是当前 Instruction Memory 的值。它们之间差了有 3 个 CC。</p> <p>注意这个改变只是最基本的，保证 pipeline 能正常运作的。它还没有解决 hazards 的问题。</p> </li> <li> <p>Control 信号：<code class="language-plaintext highlighter-rouge">EX</code>，<code class="language-plaintext highlighter-rouge">MEM(M)</code> 以及 <code class="language-plaintext highlighter-rouge">WB</code>。</p> <p>回顾单周期 CPU，除去 <code class="language-plaintext highlighter-rouge">jal</code> 使用的 jump 信号，Controller 一共给出 7 个信号。根据其作用阶段的不同，将其分为</p> <ol> <li> <p>EX (作用于 EX 阶段)：包含 <code class="language-plaintext highlighter-rouge">ALUop</code>，<code class="language-plaintext highlighter-rouge">ALUsrc</code>。</p> </li> <li> <p>MEM (作用于 MEM 阶段)：包含 <code class="language-plaintext highlighter-rouge">Branch</code>，<code class="language-plaintext highlighter-rouge">MemRead</code>，<code class="language-plaintext highlighter-rouge">MemWrite</code>。</p> </li> <li> <p>WB (作用于 WB 阶段)：包含 <code class="language-plaintext highlighter-rouge">MemToReg</code>，<code class="language-plaintext highlighter-rouge">RegWrite</code>。</p> </li> </ol> <p>可以看到，在流水线上 Controller 对应的寄存器的大小是越来越小的，这一点也很好理解，毕竟到后面的 stage 某些 control signal 就不再起作用了。</p> </li> </ul> <h3 id="data-hazard-solution">Data Hazard Solution</h3> <h4 id="1-r-r-case">1. R-R Case</h4> <p>情景：考虑以下的 RISC-V 指令：</p> <pre><code class="language-asm">sub x2, x1, x3
and x12, x2, x5
or x13, x6, x2
add x14, x2, x2
sd x15, 100(x2)
</code></pre> <p><img src="/assets/img/blog_post/co/cod-71.png" alt="cod-71" width="100%"></p> <p>从上图可以看出，Data Hazard 发生当且仅当</p> <ul> <li> <p>前序指令的 <code class="language-plaintext highlighter-rouge">rd</code> 和后序指令的 <code class="language-plaintext highlighter-rouge">rs1/rs2</code> 重合，即</p> <p>1a. <code class="language-plaintext highlighter-rouge">EX/MEM.RegisterRd</code> = <code class="language-plaintext highlighter-rouge">ID/EX.RegisterRs1</code></p> <p>1b. <code class="language-plaintext highlighter-rouge">EX/MEM.RegisterRd</code> = <code class="language-plaintext highlighter-rouge">ID/EX.RegisterRs2</code></p> <p>2a. <code class="language-plaintext highlighter-rouge">MEM/WB.RegisterRd</code> = <code class="language-plaintext highlighter-rouge">ID/EX.RegisterRs1</code></p> <p>2b. <code class="language-plaintext highlighter-rouge">MEM/WB.RegisterRd</code> = <code class="language-plaintext highlighter-rouge">ID/EX.RegisterRs2</code></p> <p>四条中有一条满足即可。</p> </li> <li> <p>执行写入操作</p> <p><code class="language-plaintext highlighter-rouge">EX/MEM.Controller.RegWrite</code> $= 1$</p> <p><code class="language-plaintext highlighter-rouge">MEM/WB.Controller.RegWrite</code> $= 1$</p> <p>要求哪条满足主要是看上面选的是 1 还是 2。</p> </li> <li> <p>不是虚空写入</p> <p><code class="language-plaintext highlighter-rouge">EX/MEM.RegisterRd</code> $\neq 0$</p> <p><code class="language-plaintext highlighter-rouge">MEM/WB.RegisterRd</code> $\neq 0$</p> <p>要求哪条满足主要是看上面选的是 1 还是 2。</p> </li> </ul> <p>所以，我们可以加入这样的逻辑来完成 Forwarding：</p> <p><img src="/assets/img/blog_post/co/cod-72.png" alt="cod-72" width="100%"></p> <h4 id="2-load-r-case">2. Load-R Case</h4> <p>情景：考虑以下的 RISC-V 指令：</p> <pre><code class="language-asm">ld x2, 20(x1)
and x4, x2, x5
or x8, x2, x6
add x9, x4, x2
</code></pre> <p><img src="/assets/img/blog_post/co/cod-73.png" alt="cod-73" width="100%"></p> <p>可以发现，第二行的指令无论如何都没有机会执行了，所以 <code class="language-plaintext highlighter-rouge">add x4, x2, x5</code> 必然会推后一个 CC。对于这一情况的判断，我们可以在上图橙色处完成。判断条件为</p> <ul> <li> <p>前序指令的 <code class="language-plaintext highlighter-rouge">rd</code> 和后序指令的 <code class="language-plaintext highlighter-rouge">rs1/rs2</code> 重合，即</p> <p>a. <code class="language-plaintext highlighter-rouge">ID/EX.RegisterRd = IF/ID.RegisterRs1</code></p> <p>b. <code class="language-plaintext highlighter-rouge">ID/EX.RegisterRd = IF/ID.RegisterRs2</code></p> <p>两条中有一条满足即可。注意上面条件的两侧不要搞反。</p> </li> <li> <p>执行 Load 操作</p> <p><code class="language-plaintext highlighter-rouge">ID/EX.Controller.MemRead</code> $= 1$</p> </li> </ul> <p>如果条件满足，我们首先要进行 Stall（熄火）。操作为</p> <ol> <li> <p>将当前指令（也就是下一个 CC 的 ID/EX）寄存器全部归零。</p> </li> <li> <p>再次读取 PC，即不调到 PC+4。</p> </li> </ol> <p>Stall 后，我们再执行 Forwarding 来保证指令的正常运行。这一部分的 Forwarding 操作和 R-R Case 几乎一致，唯一的区别是 Forwarding 的执行是在判断生效的两个 CC 后。</p> <p>下图展示了考虑 Load-R Case 的 Pipeline。可以看到主要区别是加入了 Stall 的考量。</p> <p><img src="/assets/img/blog_post/co/cod-74.png" alt="cod-74" width="100%"></p> <h3 id="branch-hazard-solution">Branch Hazard Solution</h3> <h4 id="1-static-prediction">1. Static Prediction</h4> <p>考虑以下指令：</p> <pre><code class="language-asm">36: sub x10, x4, x8
40: beq x1, x3, 32 // PC-relative branch to 40+32=72
44: and x12, x2, x5
48: orr x13, x2, x6
52: add x14, x4, x2
56: sub x15, x6, x7
...
72: ld x4, 50(x7)
</code></pre> <p>我们假设采取静态预测（预测为 Not Taken），那么有</p> <p><img src="/assets/img/blog_post/co/cod-75.png" alt="cod-75" width="90%"></p> <p>判断预测是否正确是看 <code class="language-plaintext highlighter-rouge">x1</code> 和 <code class="language-plaintext highlighter-rouge">x3</code> 是否相等。如果预测正确（的确为 Not Taken），则无事发生，所有指令照常进入流水线；如果预测错误（实际为 Taken），则需要</p> <ul> <li> <p>立刻对 IF/ID 寄存器进行 Flush，使得其下一个周期为 Bubble</p> </li> <li> <p>向 PC 中输入 PC+Offset，使 IF 获取跳转后的指令</p> </li> </ul> <p><img src="/assets/img/blog_post/co/cod-76.png" alt="cod-76" width="90%"></p> <h4 id="2-dynamic-prediction">2. Dynamic Prediction</h4> <p>基本思路是，根据之前 branch 的选择结果决定之后的选择结果。这样做的依据是，假设我们处于一个循环体之中，大多数时候我们需要 take branch，只有循环开始 / 结束的时候才是 not take branch。</p> <ul> <li> <p>1-bit predictor</p> <p>拿一个一位的寄存器存储上一次的 branch 结果。下一次 predict 根据这个 1-bit predictor 做出预测。</p> </li> <li> <p>2-bit predictor</p> <p>只会在连续两次的错误预测之后才会更改预测。从直观上看这个 predictor 更为「固执」。</p> <p><img src="/assets/img/blog_post/co/cod-77.png" alt="cod-77" width="60%"></p> </li> </ul> <h4 id="3-calculating-the-branch-target">3. Calculating the Branch Target</h4> <p>很明显，计算要跳到哪里 (Branch Target) 需要使用 ALU 进行计算，这会导致一定的延迟。</p> <p><strong>Branch Target Buffer</strong> 可以直接缓存下跳转的地址，下次就可以直接跳转并获取对应的指令。</p> <h3 id="exceptions-and-interrupts">Exceptions and Interrupts</h3> <ul> <li> <p>可能导致异常与中断的情况</p> <p>异常：例如未定义的 opcode, syscall 等。</p> <p>中断：例如外界 I/O 进行了操作导致指令中断。</p> </li> <li> <p>基本处理方法</p> <ol> <li>SEPC: 可以理解为存储出问题的 PC 的一个寄存器。</li> <li>SCAUSE: 可以理解为存储问题信息的一个寄存器。例如，SCAUSE 可以存储 opcode / hardware malfunction 等。</li> <li>handler: 可以理解为用于处理问题的专门指令。假设其地址位于 <code class="language-plaintext highlighter-rouge">0000 0000 1C09 0000</code>。</li> </ol> <p>出问题时，先将 PC 存储到 SEPC 中，然后跳到专门的 handler。</p> <p>handler 决定该采取何种措施。如果程序可重启，则采取适当措施后通过 SEPC 跳回去；反之则需要终止程序，根据 SEPC 和 SCAUSE 等信息报错。</p> </li> <li> <p>Pipeline with Exceptions</p> <p>可以看到，相比于处理 hazards 的 pipeline，这玩意儿主要是多了几个后面的指令寄存器的 flush。</p> <p><img src="/assets/img/blog_post/co/cod-78.png" alt="cod-78" width="90%"></p> <p>具体地，例如 <code class="language-plaintext highlighter-rouge">add x1, x2, x1</code> 在 ALU 阶段发生异常，我们会执行以下步骤：</p> <ol> <li>保护 <code class="language-plaintext highlighter-rouge">x1</code> 不被异常地写入。</li> <li>完成 <code class="language-plaintext highlighter-rouge">add x1, x2, x1</code> 之前的指令。</li> <li>flush 掉 <code class="language-plaintext highlighter-rouge">add</code> 及之前的所有正在处理的指令（寄存器置零）。</li> <li>设置好 SEPC 和 SCAUSE。</li> <li>跳转到 handler。</li> </ol> </li> <li> <p>Multiple Exceptions</p> <p>多重异常的情况，一般是处理最先出现的异常。</p> </li> </ul> <h3 id="instruction-level-parallelism-ilp">Instruction-Level Parallelism (ILP)</h3> <p>之前提到的 CPU 加速的方法是流水线，此外还有一种可能是：指令并行 (ILP)。</p> <p>可以预见，这是一种非常冒险的举动，但它的确可以为 CPU 再提一下速度。</p> <h4 id="1-introduction-and-terms">1. Introduction and Terms</h4> <ul> <li> <p>Multiple Issue (多发)</p> <p>可分为 static multiple issue 和 dynamic multiple issue。</p> <p>Static Multiple Issue: 编译器来决定把哪些指令「捆在一起」，以规避可能发生的 hazards。</p> <p>Dynamic Multiple Issue: CPU 来检测指令流并决定把那些指令「捆在一起」，编译器只起到辅助作用。显然这个难度更大。</p> </li> <li> <p>Speculation (前瞻执行)</p> <p>某些指令可以更早地执行（例如，提前预测并执行 branch outcome 处的指令）。当然，如果 speculation 是错误的，则需要 rollback。</p> <p>前瞻执行可以由编译器完成，亦可以由硬件完成。</p> <p>可以结合接下来的 RISC-V 静态双指令并行的例子理解 speculation。</p> </li> </ul> <h4 id="2-static-multiple-issue">2. Static Multiple Issue</h4> <p>显然，静态多发要求各个 issue slot 之内的指令互不依赖。当然，issue slot 之间的指令是可能产生依赖的。必要时，编译器可能向某个 issue slot 中加入 bubble。</p> <ul> <li> <p>RISC-V 静态双指令并行</p> <p>基本思路：一个 issue slot 装两个指令，其中一个只能为 ALU/branch，另外一个只能是 load/store。例如：</p> <p><img src="/assets/img/blog_post/co/cod-79.png" alt="cod-79" width="70%"></p> <p>考虑双指令并行的流水线 CPU 如下图所示：</p> <p><img src="/assets/img/blog_post/co/cod-80.png" alt="cod-80" width="90%"></p> <p>例如，我们可以看到 ALU 多了一个，并且多出来的那个不再接 MUX。这是因为 ld/sd 用的 ALU，其 ALUSource 已经固定。</p> <hr> <p>当然，「打包」不能乱打。例如以下两条指令显然是不能位于同一个 issue slot 的：</p> <pre><code class="language-asm">  add x10, x0, x1
  ld x2, 0(x10)
</code></pre> <p>一个打包的正确示例如下：</p> <p><img src="/assets/img/blog_post/co/cod-81.png" alt="cod-81" width="70%"></p> <p>注意：</p> <ol> <li> <code class="language-plaintext highlighter-rouge">ld x31, 0(x20)</code> 和 <code class="language-plaintext highlighter-rouge">add x31, x31, x21</code> 中间还隔了一个 CC，这是因为 load-use hazard 中间必须要空一个 CC。</li> <li> <code class="language-plaintext highlighter-rouge">sd x31, 0(x20)</code> 变为 <code class="language-plaintext highlighter-rouge">sd x31, 8(x20)</code>，这是因为我们把 <code class="language-plaintext highlighter-rouge">addi</code> 移到了 <code class="language-plaintext highlighter-rouge">sd</code> 之前。所以后做 <code class="language-plaintext highlighter-rouge">sd</code> 的话就需要做一些调整。</li> <li> <code class="language-plaintext highlighter-rouge">add x31, x31, x21</code> 和 <code class="language-plaintext highlighter-rouge">sd x31, 8(x20)</code> 之间的 data hazard 处理方法和之前讲的 R-R 基本一致，也是可以用 forwarding 无缝链接的。</li> </ol> </li> <li> <p>循环展开</p> <p>编译器层面 / 高级语言层面对循环进行展开，有利于指令并行加速。</p> <p>这个例子执行了对相邻内存中的数据增加一个固定值 <code class="language-plaintext highlighter-rouge">x21</code>。使用循环展开来使得 ALU/branch 和 load/store 能更好地耦合。</p> <p><img src="/assets/img/blog_post/co/cod-82.png" alt="cod-82" width="70%"></p> </li> </ul> <h4 id="3-dynamic-multiple-issue">3. Dynamic Multiple Issue</h4> <ul> <li> <p>动态调整指令的顺序</p> <p>为了实现动态多发，不仅是要动态地把指令归到若干个 slots 中，必要时还可以动态调整指令的执行顺序。例如</p> <pre><code class="language-asm">  ld x31, 20(x21)
  add x1, x31, x2
  sub x23, x23, x3
  andi x5, x23, 20
</code></pre> <p>可以把 <code class="language-plaintext highlighter-rouge">add</code> 和 <code class="language-plaintext highlighter-rouge">sub</code> 对换，在不影响功能的基础上规避了一个 bubble。</p> </li> <li> <p>动态多发基本框架</p> <p><img src="/assets/img/blog_post/co/cod-83.png" alt="cod-83" width="80%"></p> <p>乱序执行，顺序 commit。</p> </li> </ul> </div> </article> <br> <hr> <br> <ul class="list-disc pl-8"></ul> <h2 class="text-3xl font-semibold mb-4 mt-12">Enjoy Reading This Article?</h2> <p class="mb-2">Here are some more articles you might like to read next:</p> <li class="my-2"> <a class="text-pink-700 underline font-semibold hover:text-pink-800" href="/blog/2024/IT-NOTE-2/">Information Theory Note (Part 2 of 2)</a> </li> <li class="my-2"> <a class="text-pink-700 underline font-semibold hover:text-pink-800" href="/blog/2024/IT-NOTE-1/">Information Theory Note (Part 1 of 2)</a> </li> <li class="my-2"> <a class="text-pink-700 underline font-semibold hover:text-pink-800" href="/blog/2024/CO-NOTE-4/">Computer Organization Note (Part 4 of 4)</a> </li> <li class="my-2"> <a class="text-pink-700 underline font-semibold hover:text-pink-800" href="/blog/2024/CO-NOTE-2/">Computer Organization Note (Part 2 of 4)</a> </li> <li class="my-2"> <a class="text-pink-700 underline font-semibold hover:text-pink-800" href="/blog/2024/CO-NOTE-1/">Computer Organization Note (Part 1 of 4)</a> </li> </div> </div> <footer class="fixed-bottom" role="contentinfo"> <div class="container mt-0"> © Copyright 2025 Yuzhuo Tian. Powered by <a href="https://jekyllrb.com/" target="_blank" rel="external nofollow noopener">Jekyll</a> with <a href="https://github.com/alshedivat/al-folio" rel="external nofollow noopener" target="_blank">al-folio</a> theme. Hosted by <a href="https://pages.github.com/" target="_blank" rel="external nofollow noopener">GitHub Pages</a>. Photos from <a href="https://unsplash.com" target="_blank" rel="external nofollow noopener">Unsplash</a>. </div> </footer> <script src="https://cdn.jsdelivr.net/npm/jquery@3.6.0/dist/jquery.min.js" integrity="sha256-/xUj+3OJU5yExlq6GSYGSHk7tPXikynS7ogEvDej/m4=" crossorigin="anonymous"></script> <script src="/assets/js/bootstrap.bundle.min.js"></script> <script src="https://cdn.jsdelivr.net/npm/mdbootstrap@4.20.0/js/mdb.min.js" integrity="sha256-NdbiivsvWt7VYCt6hYNT3h/th9vSTL4EDWeGs5SN3DA=" crossorigin="anonymous"></script> <script defer src="https://cdn.jsdelivr.net/npm/masonry-layout@4.2.2/dist/masonry.pkgd.min.js" integrity="sha256-Nn1q/fx0H7SNLZMQ5Hw5JLaTRZp0yILA/FRexe19VdI=" crossorigin="anonymous"></script> <script defer src="https://cdn.jsdelivr.net/npm/imagesloaded@5.0.0/imagesloaded.pkgd.min.js" integrity="sha256-htrLFfZJ6v5udOG+3kNLINIKh2gvoKqwEhHYfTTMICc=" crossorigin="anonymous"></script> <script defer src="/assets/js/masonry.js?a0db7e5d5c70cc3252b3138b0c91dcaf" type="text/javascript"></script> <script defer src="https://cdn.jsdelivr.net/npm/medium-zoom@1.1.0/dist/medium-zoom.min.js" integrity="sha256-ZgMyDAIYDYGxbcpJcfUnYwNevG/xi9OHKaR/8GK+jWc=" crossorigin="anonymous"></script> <script defer src="/assets/js/zoom.js?85ddb88934d28b74e78031fd54cf8308"></script> <script src="/assets/js/no_defer.js?2781658a0a2b13ed609542042a859126"></script> <script defer src="/assets/js/common.js?e0514a05c5c95ac1a93a8dfd5249b92e"></script> <script defer src="/assets/js/copy_code.js?c8a01c11a92744d44b093fc3bda915df" type="text/javascript"></script> <script defer src="/assets/js/jupyter_new_tab.js?d9f17b6adc2311cbabd747f4538bb15f"></script> <script async src="https://d1bxh8uas1mnw7.cloudfront.net/assets/embed.js"></script> <script async src="https://badge.dimensions.ai/badge.js"></script> <script defer type="text/javascript" id="MathJax-script" src="https://cdn.jsdelivr.net/npm/mathjax@3.2.2/es5/tex-mml-chtml.js" integrity="sha256-MASABpB4tYktI2Oitl4t+78w/lyA+D7b/s9GEP0JOGI=" crossorigin="anonymous"></script> <script src="/assets/js/mathjax-setup.js?a5bb4e6a542c546dd929b24b8b236dfd"></script> <script defer src="https://cdnjs.cloudflare.com/polyfill/v3/polyfill.min.js?features=es6" crossorigin="anonymous"></script> <script defer src="/assets/js/progress-bar.js?2f30e0e6801ea8f5036fa66e1ab0a71a" type="text/javascript"></script> <script src="/assets/js/vanilla-back-to-top.min.js?f40d453793ff4f64e238e420181a1d17"></script> <script>
    addBackToTop();
  </script> <script type="module" src="/assets/js/search/ninja-keys.min.js?a3446f084dcaecc5f75aa1757d087dcf"></script> <ninja-keys hidebreadcrumbs noautoloadmdicons placeholder="Type to start searching"></ninja-keys> <script src="/assets/js/search-setup.js?6c304f7b1992d4b60f7a07956e52f04a"></script> <script src="/assets/js/search-data.js"></script> <script src="/assets/js/shortcut-key.js?6f508d74becd347268a7f822bca7309d"></script> </body> </html>