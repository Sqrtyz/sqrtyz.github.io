<!DOCTYPE html> <html lang="en"> <head> <meta http-equiv="Content-Type" content="text/html; charset=UTF-8"> <meta charset="utf-8"> <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no"> <meta http-equiv="X-UA-Compatible" content="IE=edge"> <title> Computer Organization Note (Part 2 of 4) | Yuzhuo Tian </title> <meta name="author" content="Yuzhuo Tian"> <meta name="description" content="Contains content about ISA."> <meta name="keywords" content="jekyll, jekyll-theme, academic-website, portfolio-website"> <link rel="stylesheet" href="/assets/css/bootstrap.min.css?a4b3f509e79c54a512b890d73235ef04"> <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/mdbootstrap@4.20.0/css/mdb.min.css" integrity="sha256-jpjYvU3G3N6nrrBwXJoVEYI/0zw8htfFnhT9ljN3JJw=" crossorigin="anonymous"> <link defer rel="stylesheet" href="/assets/css/academicons.min.css?f0b7046b84e425c55f3463ac249818f5"> <link defer rel="stylesheet" href="/assets/css/scholar-icons.css?62b2ac103a88034e6882a5be5f3e2772"> <link defer rel="stylesheet" type="text/css" href="https://fonts.googleapis.com/css?family=Roboto:300,400,500,700|Roboto+Slab:100,300,400,500,700|Material+Icons&amp;display=swap"> <link defer rel="stylesheet" href="/assets/css/jekyll-pygments-themes-github.css?591dab5a4e56573bf4ef7fd332894c99" media="" id="highlight_theme_light"> <link rel="shortcut icon" href="/assets/img/favicon.ico?f566e11424fb8bc11d484dac03de3f7f"> <link rel="stylesheet" href="/assets/css/main.css?d41d8cd98f00b204e9800998ecf8427e"> <link rel="canonical" href="https://sqrtyz.github.io/blog/2024/CO-NOTE-2/"> <script src="/assets/js/theme.js?a81d82887dd692e91686b43de4542f18"></script> <link defer rel="stylesheet" href="/assets/css/jekyll-pygments-themes-native.css?5847e5ed4a4568527aa6cfab446049ca" media="none" id="highlight_theme_dark"> <script>
    initTheme();
  </script> </head> <body class="fixed-top-nav "> <header> <nav id="navbar" class="navbar navbar-light navbar-expand-sm fixed-top" role="navigation"> <div class="container"> <a class="navbar-brand title font-weight-lighter" href="/"> <span class="font-weight-bold">Yuzhuo</span> Tian </a> <button class="navbar-toggler collapsed ml-auto" type="button" data-toggle="collapse" data-target="#navbarNav" aria-controls="navbarNav" aria-expanded="false" aria-label="Toggle navigation"> <span class="sr-only">Toggle navigation</span> <span class="icon-bar top-bar"></span> <span class="icon-bar middle-bar"></span> <span class="icon-bar bottom-bar"></span> </button> <div class="collapse navbar-collapse text-right" id="navbarNav"> <ul class="navbar-nav ml-auto flex-nowrap"> <li class="nav-item "> <a class="nav-link" href="/">about </a> </li> <li class="nav-item active"> <a class="nav-link" href="/blog/">blog </a> </li> <li class="nav-item "> <a class="nav-link" href="/publications/">publications </a> </li> <li class="nav-item "> <a class="nav-link" href="/cv/">cv </a> </li> <li class="nav-item"> <button id="search-toggle" title="Search" onclick="openSearchModal()"> <span class="nav-link">ctrl k <i class="ti ti-search"></i></span> </button> </li> <li class="toggle-container"> <button id="light-toggle" title="Change theme"> <i class="ti ti-sun-moon" id="light-toggle-system"></i> <i class="ti ti-moon-filled" id="light-toggle-dark"></i> <i class="ti ti-sun-filled" id="light-toggle-light"></i> </button> </li> </ul> </div> </div> </nav> <progress id="progress" value="0"> <div class="progress-container"> <span class="progress-bar"></span> </div> </progress> </header> <div class="container mt-5" role="main"> <div class="post"> <header class="post-header"> <h1 class="post-title">Computer Organization Note (Part 2 of 4)</h1> <p class="post-meta"> Created on January 01, 2024 </p> <p class="post-tags"> <a href="/blog/2024"> <i class="fa-solid fa-calendar fa-sm"></i> 2024 </a>   ·   <a href="/blog/tag/hardware"> <i class="fa-solid fa-hashtag fa-sm"></i> Hardware</a>   ·   <a href="/blog/category/coursenotes"> <i class="fa-solid fa-tag fa-sm"></i> CourseNotes</a> </p> </header> <article class="post-content"> <div id="markdown-content"> <h2 id="chapter-2-instructions-language-of-the-machine">Chapter 2. Instructions: Language of the Machine</h2> <h3 id="introduction">Introduction</h3> <ul> <li> <p>Process of Compiling</p> <p>编译过程：高级编程语言 $\to$ 汇编语言 $\to$ 机器语言。</p> <p>例如，<code class="language-plaintext highlighter-rouge">A + B</code> $\to$ <code class="language-plaintext highlighter-rouge">add A, B</code> $\to$ <code class="language-plaintext highlighter-rouge">1000110010100000</code>。</p> </li> <li> <p>Instruction</p> <p>指令是「机器的语言」。如果说 Instruction 是 Word，那么 Instruction set 则是 Vocabulary。</p> <p>本课程采取的指令集为 RISC-V。这是一种精简指令集。</p> <p>关于汇编语言和指令集的关系，摘取两条知乎回答：</p> <blockquote> <p>汇编语言是用人类看得懂的语言来描述指令集。否则指令集的机器码都是一堆二进制数字，人类读起来非常麻烦，但汇编是用类似人类语言的方式描述指令集，读起来方便多了。</p> </blockquote> <blockquote> <p>汇编指令是让人看得懂的，只是指令集的另外一种表示形式。</p> </blockquote> </li> <li> <p>RISC vs. CISC</p> <p><img src="/assets/img/blog_post/co/cod-31.png" alt="cod-31" width="50%"></p> </li> </ul> <h3 id="basics-instructions-and-registers">Basics: Instructions and Registers</h3> <ul> <li> <p>Instruction Formats</p> <p><img src="/assets/img/blog_post/co/cod-32.png" alt="cod-32" width="50%"></p> <p>前者是可以理解为操作类型，后者可以理解为操作参数。</p> </li> <li> <p>Register Operands</p> <p>对于 RISC-V 指令集，其使用的寄存器类型为 $32\times 64\text{-bit}$。可以想象成一个寄存器有 32 行，每一行有一个变量，其长度为 64 bits（等于 8 bytes，是一个 double / long long 的大小，也被称为 dword）。</p> <p>这些寄存器的「各行」各司其职。其职能如下表所示。</p> <p><img src="/assets/img/blog_post/co/cod-33.png" alt="cod-33" width="50%"></p> <p>举个例子：<code class="language-plaintext highlighter-rouge">f = (g + h) - (i + j);</code>，我们假设目前 $f,g,h,i,j$ 的值分别位于地址 x19, x20, x21, x22, x23。</p> <p>那么我们应该这样描述 RISC-V 指令：</p> <div class="language-plaintext highlighter-rouge"> <div class="highlight"><pre class="highlight"><code>  add x5, x20, x21
  add x6, x22, x23
  sub x19, x5, x6
</code></pre></div> </div> </li> </ul> <h3 id="al-1-arithmetic-logical-and-memory">AL 1: Arithmetic, Logical and Memory</h3> <ul> <li> <p>Add and Subtraction</p> <table> <thead> <tr> <th>Category</th> <th>Instruction</th> <th>Example</th> <th>Meaning</th> <th>Comments</th> <th>Type</th> </tr> </thead> <tbody> <tr> <td>Arithmetic</td> <td>add</td> <td><code class="language-plaintext highlighter-rouge">add a,b,c</code></td> <td>$a \gets b+c$</td> <td>Always 3 operand</td> <td>R</td> </tr> <tr> <td>Arithmetic</td> <td>subtract</td> <td><code class="language-plaintext highlighter-rouge">sub a,b,c</code></td> <td>$a \gets b-c$</td> <td>Always 3 operand</td> <td>R</td> </tr> </tbody> </table> </li> <li> <p>Immediate Arithmetic</p> <table> <thead> <tr> <th>Category</th> <th>Instruction</th> <th>Example</th> <th>Meaning</th> <th>Comments</th> <th>Type</th> </tr> </thead> <tbody> <tr> <td>Arithmetic</td> <td>addi immediate</td> <td><code class="language-plaintext highlighter-rouge">addi a,b,c</code></td> <td>$a \gets b+c$</td> <td>$c$ is a constant</td> <td>I</td> </tr> </tbody> </table> </li> <li> <p>Logical Arithmetic</p> <p><img src="/assets/img/blog_post/co/cod-39.png" alt="cod-39" width="50%"></p> <p><img src="/assets/img/blog_post/co/cod-40.png" alt="cod-40" width="50%"></p> <p>（懒得敲表格了，直接截图）</p> </li> <li> <p>Memory Operations</p> <ul> <li> <p>Basics</p> <ol> <li>执行算术操作：先从 memory 中读到 reg，在 reg 中进行运算，最后输回到 reg。</li> <li>Memory 的地址是 <strong>按 byte 定义的</strong>。</li> <li>RISC-V 采取小端。</li> </ol> </li> <li> <p>Example</p> <p>考虑 C 代码：</p> <div class="language-c highlighter-rouge"> <div class="highlight"><pre class="highlight"><code>  <span class="n">A</span><span class="p">[</span><span class="mi">12</span><span class="p">]</span> <span class="o">=</span> <span class="n">h</span> <span class="o">+</span> <span class="n">A</span><span class="p">[</span><span class="mi">8</span><span class="p">];</span> <span class="c1">// here A is a double</span>
</code></pre></div> </div> <p>假设 h 在 reg 中的值位于 x21，A 在 memory 中的地址值保存在 reg 中的 x22。</p> <p>用 RISC-V 表示：</p> <div class="language-plaintext highlighter-rouge"> <div class="highlight"><pre class="highlight"><code>  ld x9, 64(x22)
  add x9, x21, x9
  sd x9, 96(x22)
</code></pre></div> </div> <ol> <li>第一行：由于 A 是 double 类型，所以 A[8] 相对于 A 的偏移为 64。<code class="language-plaintext highlighter-rouge">ld</code> 用于从 mem 读到 reg，使用 <code class="language-plaintext highlighter-rouge">ld x9, 64(x22)</code> 将 A 地址向后偏移 64 bytes 处的值读入到 reg 的 x9 中。</li> <li>第二行：执行加法。</li> <li>第三行：将 reg 的 x9 中的值输出到 mem 中。具体位置是 x22 所存地址向后偏移 96。</li> </ol> <table> <thead> <tr> <th>Category</th> <th>Instruction</th> <th>Example</th> <th>Meaning</th> <th>Comments</th> <th>Type</th> </tr> </thead> <tbody> <tr> <td>Data Transfer</td> <td>load dword</td> <td><code class="language-plaintext highlighter-rouge">ld x5, 40(x6)</code></td> <td>x5 = Mem[x6+40]</td> <td>dword from mem to reg</td> <td>I</td> </tr> <tr> <td>Data Transfer</td> <td>store dword</td> <td><code class="language-plaintext highlighter-rouge">sd x5, 40(x6)</code></td> <td>Mem[x6+40] = x5</td> <td>dword from reg to mem</td> <td>S</td> </tr> </tbody> </table> </li> </ul> </li> <li> <p>Sign Extension</p> <p>Example: 8-bit to 16-bit</p> <p>+2: 0000 0010 =&gt; 0000 0000 0000 0010</p> <p>-2: 1111 1110 =&gt; 1111 1111 1111 1110</p> <p>在 RISC-V 中，<code class="language-plaintext highlighter-rouge">lb</code> 操作用于执行「同符号位拓展」，<code class="language-plaintext highlighter-rouge">lbu</code> 操作用于执行「补 0 位拓展」。</p> </li> </ul> <h3 id="ml-1-representing-instructions-of-r--i--s">ML 1: Representing Instructions of R / I / S</h3> <ul> <li> <p>汇编码 $\to$ 机器码</p> <p>一个例子如下：</p> <p><img src="/assets/img/blog_post/co/cod-34.png" alt="cod-34" width="50%"></p> <p>可以看到，汇编码向机器码的转换已经很好理解了。更具体一点，它的规则如下：</p> <p><img src="/assets/img/blog_post/co/cod-35.png" alt="cod-35" width="50%"></p> <p>一条指令的长度恒为 32 位。注意构成 operator 的不止有 opcode，还有 funct7 和 funct3。例如，<code class="language-plaintext highlighter-rouge">add</code> 和 <code class="language-plaintext highlighter-rouge">sub</code> 的 opcode 实际上是相同的。</p> <p>实际上，这种机器码指令为 R 型指令，他只是众多机器码指令类型中的一种。</p> <p><img src="/assets/img/blog_post/co/cod-36.png" alt="cod-36" width="50%"></p> <ul> <li> <p>R-Format Instructions</p> <p>主要包含 arithmetic。格式和意义如上所示。</p> </li> <li> <p>I-Format Instructions</p> <p>主要包含 immediate arithmetic 和 load instructions。</p> <p><img src="/assets/img/blog_post/co/cod-37.png" alt="cod-37" width="50%"></p> </li> <li> <p>S-Format Instructions</p> <p>主要包含 store instructions。</p> <p><img src="/assets/img/blog_post/co/cod-38.png" alt="cod-38" width="50%"></p> </li> </ul> </li> </ul> <h3 id="al-2-decision-instructions">AL 2: Decision Instructions</h3> <p>基本 RISC-V 语句：beq &amp; bne</p> <table> <thead> <tr> <th>Category</th> <th>Instruction</th> <th>Example</th> <th>Meaning</th> <th>Type</th> </tr> </thead> <tbody> <tr> <td>Decision</td> <td>equal</td> <td><code class="language-plaintext highlighter-rouge">beq rs1, rs2, L1</code></td> <td>if (<code class="language-plaintext highlighter-rouge">rs1 == rs2</code>) branch to instruction labeled L1</td> <td>SB</td> </tr> <tr> <td>Decision</td> <td>not equal</td> <td><code class="language-plaintext highlighter-rouge">bne rs1, rs2, L1</code></td> <td>if (<code class="language-plaintext highlighter-rouge">rs1 != rs2</code>) branch to instruction labeled L1</td> <td>SB</td> </tr> <tr> <td>Decision</td> <td>less than</td> <td><code class="language-plaintext highlighter-rouge">blt rs1, rs2, L1</code></td> <td>if (<code class="language-plaintext highlighter-rouge">rs1 &lt; rs2</code>) branch to instruction labeled L1</td> <td>SB</td> </tr> <tr> <td>Decision</td> <td>greater than</td> <td><code class="language-plaintext highlighter-rouge">bge rs1, rs2, L1</code></td> <td>if (<code class="language-plaintext highlighter-rouge">rs1 &gt;= rs2</code>) branch to instruction labeled L1</td> <td>SB</td> </tr> </tbody> </table> <p>Unsigned comparison: <code class="language-plaintext highlighter-rouge">bltu</code>, <code class="language-plaintext highlighter-rouge">bgeu</code>（在后面加 u 变成无符号）</p> <ul> <li> <p>单 if 情况</p> <p>考虑 C 代码：</p> <div class="language-c highlighter-rouge"> <div class="highlight"><pre class="highlight"><code>  <span class="k">if</span> <span class="p">(</span><span class="n">i</span> <span class="o">==</span> <span class="n">j</span><span class="p">)</span> <span class="k">goto</span> <span class="n">L1</span><span class="p">;</span>
  <span class="n">f</span> <span class="o">=</span> <span class="n">g</span> <span class="o">+</span> <span class="n">h</span><span class="p">;</span>
  <span class="n">L1</span><span class="o">:</span> <span class="n">f</span> <span class="o">=</span> <span class="n">f</span> <span class="o">-</span> <span class="n">i</span><span class="p">;</span>
</code></pre></div> </div> <p>对应的 RISC-V 汇编代码：</p> <div class="language-plaintext highlighter-rouge"> <div class="highlight"><pre class="highlight"><code>  beq x21, x22, L1      # go to L1 if i equals j
  add x19, x20, x21     # f = g + h ( skipped if i equals j )
  L1: sub x19, x19, x22 # f = f - i ( always executed )
</code></pre></div> </div> </li> <li> <p>if-else 情况</p> <p>考虑 C 代码：</p> <div class="language-c highlighter-rouge"> <div class="highlight"><pre class="highlight"><code>  <span class="k">if</span> <span class="p">(</span><span class="n">i</span> <span class="o">==</span> <span class="n">j</span><span class="p">)</span> <span class="n">f</span> <span class="o">=</span> <span class="n">g</span> <span class="o">+</span> <span class="n">h</span><span class="p">;</span>
  <span class="k">else</span> <span class="n">f</span> <span class="o">=</span> <span class="n">g</span> <span class="o">-</span> <span class="n">h</span><span class="p">;</span>
</code></pre></div> </div> <p>对应的 RISC-V 汇编代码（Assume that f~j are located at x19~x23）：</p> <div class="language-plaintext highlighter-rouge"> <div class="highlight"><pre class="highlight"><code>  bne x22, x23, Else  # go to Else if i != j
  add x19, x20, x21  # f = g + h ( Executed if i == j )
  beq x0, x0, EXIT  # always go to Exit
  Else: sub x19, x20, x21  # f = g - h ( Executed if i ≠ j ) 
  Exit:  # the first instruction of the next C 
</code></pre></div> </div> </li> <li> <p>LOOPs 情况</p> <p>考虑 C 代码：</p> <div class="language-c highlighter-rouge"> <div class="highlight"><pre class="highlight"><code>  <span class="nl">Loop:</span> <span class="n">g</span> <span class="o">=</span> <span class="n">g</span> <span class="o">+</span> <span class="n">A</span><span class="p">[</span><span class="n">i</span><span class="p">];</span> <span class="c1">// A is an array of 100 words</span>
  <span class="n">i</span> <span class="o">=</span> <span class="n">i</span> <span class="o">+</span> <span class="n">j</span><span class="p">;</span>
  <span class="k">if</span> <span class="p">(</span> <span class="n">i</span> <span class="o">!=</span> <span class="n">h</span> <span class="p">)</span> <span class="k">goto</span> <span class="n">Loop</span><span class="p">;</span>
</code></pre></div> </div> <p>对应的 RISC-V 汇编代码（Assume that f~j are located at x19~x23, base of A is stored in x25）：</p> <div class="language-plaintext highlighter-rouge"> <div class="highlight"><pre class="highlight"><code>  Loop: slli x10, x22, 3 # temp reg x10 = 8 * i
  add x10, x10, x25      # x10 = address of A[i]
  ld x19, 0(x10)         # temp reg x19 = A[i]
  add x20, x20, x19      # g = g + A[i]
  add x22, x22, x23      # i = i + j
  bne x22, x21, Loop     # go to Loop if i != h
</code></pre></div> </div> <p>第一行 <code class="language-plaintext highlighter-rouge">x22</code> 乘以 $8$ 之后放入 <code class="language-plaintext highlighter-rouge">x10</code>，和第二行共同计算出了 $A_i$ 的内存地址，置于 x10。</p> <p>第三行将 $A_i$ 的值读入到 <code class="language-plaintext highlighter-rouge">x19</code>。注意此处 <code class="language-plaintext highlighter-rouge">0(x10)</code> 中 <code class="language-plaintext highlighter-rouge">0</code> 只能是常量，因而不能用之前的那种寻址方式。</p> </li> <li> <p>while 情况</p> <p>考虑 C 代码：</p> <div class="language-c highlighter-rouge"> <div class="highlight"><pre class="highlight"><code>  <span class="k">while</span> <span class="p">(</span><span class="n">save</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">==</span> <span class="n">k</span><span class="p">)</span>
      <span class="n">i</span> <span class="o">+=</span> <span class="mi">1</span><span class="p">;</span>
</code></pre></div> </div> <p>对应的 RISC-V 汇编代码（Assume i~k are located at x22~x24, base of save is stored in x25）：</p> <div class="language-plaintext highlighter-rouge"> <div class="highlight"><pre class="highlight"><code>  Loop: slli x10, x22, 3 # temp reg $t1 = 8 * i
  add x10, x10, x25      # x10 = address of save[i]
  ld x9, 0(x10)          # x9 gets save[i]
  bne x9, x24, Exit      # go to Exit if save[i] != k
  addi x22, x22, 1       # i += 1
  beq x0, x0, Loop       # go to Loop 
  Exit:
</code></pre></div> </div> </li> <li> <p>比较</p> <p>使用 <code class="language-plaintext highlighter-rouge">blt</code>, <code class="language-plaintext highlighter-rouge">bge</code> 表示变量比较形式的选择。例如 <code class="language-plaintext highlighter-rouge">blt rs1, rs2, L1</code> 表示如果 rs1 &lt; rs2 则跳到 L1 标签处的指令。</p> <p>注意 <code class="language-plaintext highlighter-rouge">bltu</code>, <code class="language-plaintext highlighter-rouge">bgeu</code> 表示无符号比较。使用这种比较方式可能会导致比较结果不同。</p> <p><img src="/assets/img/blog_post/co/cod-41.png" alt="cod-41" width="50%"></p> </li> </ul> <h3 id="al-3-jump-register">AL 3: Jump Register</h3> <p>RISC-V 中的无条件跳转主要包含两种指令：<code class="language-plaintext highlighter-rouge">jal</code> 和 <code class="language-plaintext highlighter-rouge">jalr</code>。</p> <table> <thead> <tr> <th>Category</th> <th>Instruction</th> <th>Example</th> <th>Meaning</th> <th>Type</th> </tr> </thead> <tbody> <tr> <td>Unconditional branch</td> <td>jump and link</td> <td><code class="language-plaintext highlighter-rouge">jal x1, 100</code></td> <td>x1 = PC + 4; go to PC+100</td> <td>UJ</td> </tr> <tr> <td>Unconditional branch</td> <td>jump and link register</td> <td><code class="language-plaintext highlighter-rouge">jalr x1, 100(x5)</code></td> <td>x1 = PC + 4; go to x5+100</td> <td>I</td> </tr> </tbody> </table> <p>这之中 PC 的意思是当前指令的地址。实际上，所有指令都存储在内存之中（后面会再讲）。这里跳实际上也是一种「在内存里跳」。注意每个指令的长度为 32 bits。</p> <p><code class="language-plaintext highlighter-rouge">jal</code> 可以理解为相对位置跳转，<code class="language-plaintext highlighter-rouge">jalr</code> 可以理解为绝对位置跳转。</p> <ul> <li> <p>使用 Jump address table 来指导跳转</p> <p>考虑这样的 C 代码，其中 $f\sim k$ 存储在 x20 ~ x25 中。</p> <pre><code class="language-C">  switch ( k ) {
      case 0 : f = i + j ; break ; /* k = 0 */
      case 1 : f = g + h ; break ; /* k = 1 */
      case 2 : f = g - h ; break ; /* k = 2 */
      case 3 : f = i - j ; break ; /* k = 3 */
  }
</code></pre> <p>其 RISC-V 指令如下：</p> <p><img src="/assets/img/blog_post/co/cod-42.png" alt="cod-42" width="50%"></p> <p>从内存中的 x6 开始一段，存储着我们用来辅助跳转的 Jump address table。第四行根据 $k$ 的值，将目标的精确 address 在内存中的存放位置赋给 x7。第五行执行后则 x7 获得了目标指令的 address（其实就是在内存 text 段的 address）。最后通过第六行跳转到对应指令。</p> </li> </ul> <h3 id="supporting-procedures">Supporting Procedures</h3> <p>本部分进一步讲解 jal, jalr, bne, beq 这类能搞跳转的指令。</p> <ul> <li> <p>指令的存储</p> <p>在将指令的存储前，首先讲内存的架构。</p> <p><img src="/assets/img/blog_post/co/cod-43.png" alt="cod-43" width="50%"></p> <p>从下到上依次为：</p> <ol> <li>Reserved 此部分保留。</li> <li>Text 此部分 <strong>用于存储指令</strong>。之前看到指令的跳转也是以 byte 为单位的，这是因为它在内存之中，而内存的寻址亦为 byte 单位。</li> <li>Static Data 静态数据。这部分很好理解。</li> <li>Dynamic Data 动态数据。这部分很好理解。</li> <li>Stack 堆栈。这部分后面会讲，通常用于暂存一些 reg 中需要用到的量。</li> </ol> </li> <li> <p>常见的 Procedure Call 流程</p> <p>首先是 <strong>Caller</strong>。其指令一般为 <code class="language-plaintext highlighter-rouge">jal x1, ProcedureAddress</code>。注意此语句后， x1 中会 <strong>自动存放下一段指令的地址（即 PC + 4）</strong>。</p> <p>然后是 <strong>Callee</strong>。其指令一般为 <code class="language-plaintext highlighter-rouge">jalr x0, 0(x1)</code>。可以看到我们直接跳到 <code class="language-plaintext highlighter-rouge">(x1)</code>，因为在跳之前 <code class="language-plaintext highlighter-rouge">x1</code> 已被赋好了值；此外第一个 operand 为 <code class="language-plaintext highlighter-rouge">x0</code> 是因为我们不关心 callee 的地址，只用返回去即可（即没有必要存储 callee 的地址）。</p> </li> <li> <p>堆栈</p> <p>在指令跳转的途中，有可能我们后面希望跳回来，但同时也希望跳之前 Caller 使用的部分 reg 得以保留。通常这是很难做到的，所以我们使用堆栈来先将 Caller 使用的寄存器的值保存下来，Callee 使用寄存器后再复原，以便接下来 Caller 再使用。</p> <p>首先再次明确 RISC-V 寄存器的变量区域划分，同时我们也重新做一些记号：</p> <table> <thead> <tr> <th>Category</th> <th>Notation</th> <th>Register</th> </tr> </thead> <tbody> <tr> <td>Arguments</td> <td>a0 ~ a7</td> <td>x10 ~ x17</td> </tr> <tr> <td>Saved</td> <td>s0 ~ 11</td> <td>x8 ~ x9, x18 ~ x27</td> </tr> <tr> <td>Temporary</td> <td>t0 ~ t6</td> <td>x5 ~ x7, x28 ~ x31</td> </tr> </tbody> </table> <p>可以这样理解各类变量：比如在调用一个递归的 C 函数 <code class="language-plaintext highlighter-rouge">f(k)</code> 时，$k$ 和 $f(k)$ 的返回值都可以视作 Argument；而其中运算的中间值，递归完回来还要用的可视作 Saved；其中运算的中间值，递归完回来不用，仅仅作为中间运算结果的，可以视作 Temporary。</p> <p>之前讲到堆栈是地址最高的。同时，堆栈的 top 也是地址更低的。如下图所示。</p> <p><img src="/assets/img/blog_post/co/cod-44.png" alt="cod-44" width="50%"></p> <p>考虑这样一个例子：C 代码实现递归阶乘</p> <pre><code class="language-C">  int fact ( int n ) {
      if ( n &lt; 1 ) return ( 1 ) ;
      else return ( n * fact ( n - 1 ) ) ;
  } 
</code></pre> <p>其 RISC-V 汇编代码如下：</p> <p><img src="/assets/img/blog_post/co/cod-45.png" alt="cod-45" width="50%"></p> <p>Line 1-3 开了两个栈空间，并把 <code class="language-plaintext highlighter-rouge">ra</code> 和 <code class="language-plaintext highlighter-rouge">a0</code>（对应 x10，一般用于存储输入参数和输出结果）存入堆栈。</p> <p>Line 4-5 在比较 $n$ 和 $1$ 的关系。</p> <ul> <li> <p>如果 $ n \leq 1$，进入 <code class="language-plaintext highlighter-rouge">L1</code> (Line 9)。注意到 Line 9 首先将 <code class="language-plaintext highlighter-rouge">a0</code> 减了一以便开始下一层递归（这也是为什么开始要把 <code class="language-plaintext highlighter-rouge">a0</code> 存进堆栈）；Line 10 则跳转到 <code class="language-plaintext highlighter-rouge">fact</code> (Line 1)，此行指令也会把 <code class="language-plaintext highlighter-rouge">ra</code> 的值改变（这也是为什么开始要把 <code class="language-plaintext highlighter-rouge">ra</code> 存进堆栈）。</p> </li> <li> <p>执行完 $fact(n-1)$ 后，回到 Line 11。此时 <code class="language-plaintext highlighter-rouge">a0</code> 已然是递归后 $fact(n-1)$ 的结果，先把它转入 <code class="language-plaintext highlighter-rouge">t1</code> 临时变量中。随后读取之前存好的 <code class="language-plaintext highlighter-rouge">a0</code> 和 <code class="language-plaintext highlighter-rouge">ra</code>，读取之后 <code class="language-plaintext highlighter-rouge">a0</code> 就是当前进程的 argument（即 $n$），<code class="language-plaintext highlighter-rouge">ra</code> 就是要回去的 Caller 地址。</p> <p>Line 15 使得 <code class="language-plaintext highlighter-rouge">a0</code> 变身 result 为一会儿返回的 caller 服务。Line 16 跳回 Caller。</p> </li> </ul> <p><strong>SUMMARY</strong></p> <p>一般而言，caller 要对 temporary / argument 寄存器负责。即根据自己的情况决定这两类数据是否要存储到堆栈中。</p> <p>而 callee 则对 saved 寄存器和 ra 负责。按照约定，在使用 saved 寄存器前，callee 必须先将 saved 中的变量存入堆栈；此外，callee 在执行指令前必须先将 ra 存入寄存器来确保待会儿能重返 caller。</p> </li> </ul> <h3 id="other-width">Other Width</h3> <p>之前说的 load / store 都是以 dword 为单位的（指令为 <code class="language-plaintext highlighter-rouge">ld</code> 和 <code class="language-plaintext highlighter-rouge">sd</code>）。实际上也可以读写 byte / halfword / word。例如，要 load byte / halfword / word 的格式则为</p> <div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>lb rd, offset(rs1)
lh rd, offset(rs1)
lw rd, offset(rs1)
</code></pre></div></div> <h3 id="ml-2-addressing-for-32-bit-immediate-and-addresses">ML 2: Addressing for 32-Bit Immediate and Addresses</h3> <p>这部分讲解 32 位立即数赋值 / 32 位寻址的机器码层面具体实现。</p> <ul> <li> <p>32-Bit Immediate Addressing (U-Type)</p> <p>指令 <code class="language-plaintext highlighter-rouge">lui</code>：将一个 register 的高 20 位设为常值。</p> <table> <thead> <tr> <th>Category</th> <th>Instruction</th> <th>Example</th> <th>Meaning</th> <th>Type</th> </tr> </thead> <tbody> <tr> <td>Data transfer</td> <td>Load upper immediate</td> <td><code class="language-plaintext highlighter-rouge">lui x5, 0x12345</code></td> <td>x5 = 0x12345000, Loads 20-bits constant shifted</td> <td>U</td> </tr> </tbody> </table> <p><img src="/assets/img/blog_post/co/cod-46.png" alt="cod-46" width="50%"></p> <p>实际上的 RISC-V reg 是 64 位的。在这里我们对低 32 位赋予立即数。之所以要分两次赋予常值是因为一次的大小不够。</p> </li> <li> <p>Branch Addressing (SB-Type)</p> <p>上回说到 bne 的格式是 <code class="language-plaintext highlighter-rouge">bne rs1, rs2, L1</code> 其中 <code class="language-plaintext highlighter-rouge">L1</code> 是某个标签，表示了某处的指令。然而实际上机器肯定无法识别 <code class="language-plaintext highlighter-rouge">L1</code>，所以实际上这里 L1 翻译成机器码是一个 offset。</p> <p>举例：<code class="language-plaintext highlighter-rouge">bne x10, x11, 2000</code>（2000 = 0111 1101 0000）</p> <p><img src="/assets/img/blog_post/co/cod-47.png" alt="cod-47" width="50%"></p> <p>上图的 Inst 那一行有些神金，首先一般不用 Inst 表示（就用 imm），然后应该最低位从 0 开始。</p> <p>注意，由于所有的 RISC-V 指令都是 32 位的（本课程不讨论 16 位），所以指令的地址（byte 单位）一定满足末两位为 0。所以 RISC-V 的设计者决定在实际机器编码时，省略 offset 的最后一位，只将 offset 中的非 LSB 部分写入机器码（这样可以使 offset 支持更远的距离）。</p> </li> <li> <p>Jump Addressing (UJ-Type)</p> <p>考虑 <code class="language-plaintext highlighter-rouge">jal</code> 指令，其指令格式为 UJ 型。</p> <p>举例：<code class="language-plaintext highlighter-rouge">jal x0 2000</code>，表示跳转到 $\text{offset} = 2000_{(10)}$ 的位置，没有向 <code class="language-plaintext highlighter-rouge">ra</code> 中存入内容。</p> <p><img src="/assets/img/blog_post/co/cod-48.png" alt="cod-48" width="50%"></p> <p>其中 2000 (offset) 存储在 imm 部分；x0 存储在 rd 部分，表示的是某个寄存器地址。</p> <p>注意其中 <code class="language-plaintext highlighter-rouge">imm[20] (inst[31])</code> 表示的是 <strong>符号位</strong>。当其为 $1$ 实际上是往之前的指令跳。</p> <p>此外，和 Branch Addressing 一样，offset 的最后一位不再反映到机器码中，默认 offset 的最后一位一定为零。</p> </li> <li> <p>An Example: C $\to$ Assembly $\to$ Machine</p> <p><img src="/assets/img/blog_post/co/cod-49.png" alt="cod-49" width="50%"></p> <p>解读 bne 那一行：rs1 表示的是 x9，rs2 表示的是 x24。对于 SB-Type 指令，funct7 和 rd 列共同组成了 immediate。可以看到本指令的立即数为 <code class="language-plaintext highlighter-rouge">000000000110(0)</code> （最后一个 0 在机器码中被省去），对应的就是 +12。而我们看到 bne 和 Exit 差 3 条指令，即为 12 Bytes。</p> </li> </ul> <h3 id="summary">SUMMARY</h3> <p><img src="/assets/img/blog_post/co/cod-36.png" alt="cod-36" width="50%"></p> <p>个人感觉指令基本上是按「格式」分类，而不是「作用」分类。</p> <ul> <li> <p>R 型：<strong>主要用于「算术操作」</strong>。rd 表示被赋值寄存器，rs1 和 rs2 表示操作数。</p> </li> <li> <p>I 型：<strong>目前可用于「load」「立即数算术」「jalr」</strong>。load 和 jalr 的共同点是都有一个基地址 rs1，同时有一个偏移量 imm。随后它们的 rd 都会改变，load 会把内存中读到的值放进 rd，jalr 会把 PC+4 放进 rd。</p> </li> <li> <p>SB 型：<strong>目前可用于「选择型跳转」</strong>。rs1 和 rs2 执行某种比较运算，跳转的偏移量存储在 imm 中。</p> </li> <li> <p>UJ 型：<strong>目前可用于「jal」</strong>。jal 只有一个偏移量 offset，同时也会把 PC+4 放进 rd。</p> </li> <li> <p>U 型：<strong>目前可用于「立即数赋值」</strong>。把 imm 放进 rd（取低 32 位）的高 20 位。</p> </li> <li> <p>S 型：<strong>目前可用于「store」</strong>。store 会把 rs2 寄存器中的内容写入基地址 rs1，偏移量 imm 的位置。</p> </li> </ul> <p>可以看到，rs1 / rs2 / rd / imm 都是有其意义的。</p> <ul> <li> <p>imm 通常表示常量，所以也经常表示 offset。注意 imm 的「上下界」（比如 <code class="language-plaintext highlighter-rouge">imm[31:12]</code>）有其意义。大概是，如果 imm 用于表示某指令的 X 部分，则 <code class="language-plaintext highlighter-rouge">imm[a:b]</code> 表示 imm 部分表示的是 <code class="language-plaintext highlighter-rouge">X[a:b]</code>。</p> </li> <li> <p>rs1 通常表示基地址。也有的时候表示第一个操作数。</p> </li> <li> <p>rd 通常是一个会被写入新内容的寄存器地址。</p> </li> <li> <p>rs2 则通常表示第二个操作数。</p> </li> </ul> <h3 id="some-extensions-of-ch2">Some Extensions of CH2</h3> <ol> <li> <p>Synchronization in RISC-V (RISC-V 同步问题)</p> <p>考虑同时有两个处理器 P1 和 P2 在读写同一块内存。如果不进行同步 (Synchronization) 则有可能产生冲突。</p> <p>首先介绍两个新指令 <code class="language-plaintext highlighter-rouge">lr.d</code>，<code class="language-plaintext highlighter-rouge">sc.d</code>：</p> <table> <thead> <tr> <th>Category</th> <th>Instruction</th> <th>Example</th> <th>Meaning</th> </tr> </thead> <tbody> <tr> <td>Data transfer</td> <td>Load-Reserved Dword</td> <td><code class="language-plaintext highlighter-rouge">lr.d rd, (rs1)</code></td> <td>从内存中地址为 rs1 加载 8 个字节，写入 rd，并对内存 <strong>双字注册保留</strong> </td> </tr> <tr> <td>Data transfer</td> <td>Store-Conditional Dword</td> <td><code class="language-plaintext highlighter-rouge">sc.d rd, rs2, (rs1)</code></td> <td>若内存地址 rs1 上存在加载保留，将 rs2 寄存器中的 8 字节数存入该地址，并向寄存器 rd 中存入 0；否则存入非 0 错误码</td> </tr> </tbody> </table> <p>简单来说，<code class="language-plaintext highlighter-rouge">lr.d</code> 会对地址为 <code class="language-plaintext highlighter-rouge">rs1</code> 的内存打上标记。若在下次 <code class="language-plaintext highlighter-rouge">rs1</code> 被 <code class="language-plaintext highlighter-rouge">sc.d</code> 之前 <code class="language-plaintext highlighter-rouge">rs1</code> 没被动过，则 <code class="language-plaintext highlighter-rouge">sc.d</code> 成功执行并返回 $0$；反之（被动过）则 <code class="language-plaintext highlighter-rouge">sc.d</code> 返回 $1$。</p> <p>接下来介绍两个例子，通过 <code class="language-plaintext highlighter-rouge">lr.d</code> 和 <code class="language-plaintext highlighter-rouge">sc.d</code> 来避免内存的读写冲突。</p> <ul> <li> <p>Example 1. Atomic Swap</p> <div class="language-as highlighter-rouge"> <div class="highlight"><pre class="highlight"><code>  <span class="nx">again</span><span class="o">:</span> <span class="nx">lr</span><span class="p">.</span><span class="nx">d</span> <span class="nx">x10</span><span class="p">,</span> <span class="p">(</span><span class="nx">x20</span><span class="p">)</span>
  <span class="nx">sc</span><span class="p">.</span><span class="nx">d</span> <span class="nx">x11</span><span class="p">,</span> <span class="p">(</span><span class="nx">x20</span><span class="p">),</span> <span class="nx">x23</span>  <span class="c1">// X11 = status</span>
  <span class="nx">bne</span> <span class="nx">x11</span><span class="p">,</span> <span class="nx">x0</span><span class="p">,</span> <span class="nx">again</span>    <span class="c1">// branch if store failed</span>
  <span class="nx">addi</span> <span class="nx">x23</span><span class="p">,</span> <span class="nx">x10</span><span class="p">,</span> <span class="mi">0</span>      <span class="c1">// X23 = loaded value</span>
</code></pre></div> </div> <p>本段 RISC-V 指令实现了将寄存器 x23 和地址为 x20 的内存进行数值交换。注意如果 x11 非零说明 <code class="language-plaintext highlighter-rouge">sc.d</code> 不成功，即一二行指令之间可能发生了 x20 又被其他处理器覆写的情况。这种情况我们重新到 again 开始 swap，保证所有操作是 atomic 的。</p> </li> <li> <p>Example 2. Lock</p> <div class="language-as highlighter-rouge"> <div class="highlight"><pre class="highlight"><code>  <span class="nx">addi</span> <span class="nx">x12</span><span class="p">,</span> <span class="nx">x0</span><span class="p">,</span> <span class="mi">1</span>         <span class="c1">// copy locked value</span>
  <span class="nl">again</span><span class="p">:</span> <span class="nx">lr</span><span class="p">.</span><span class="nx">d</span> <span class="nx">x10</span><span class="p">,</span> <span class="p">(</span><span class="nx">x20</span><span class="p">)</span>  <span class="c1">// read lock</span>
  <span class="nx">bne</span> <span class="nx">x10</span><span class="p">,</span> <span class="nx">x0</span><span class="p">,</span> <span class="nx">again</span>      <span class="c1">// check if it is 0 yet</span>
  <span class="nx">sc</span><span class="p">.</span><span class="nx">d</span> <span class="nx">x11</span><span class="p">,</span> <span class="p">(</span><span class="nx">x20</span><span class="p">),</span> <span class="nx">x12</span>    <span class="c1">// attempt to store</span>
  <span class="nx">bne</span> <span class="nx">x11</span><span class="p">,</span> <span class="nx">x0</span><span class="p">,</span> <span class="nx">again</span>      <span class="c1">// branch if fail</span>
</code></pre></div> </div> <p>To unlock:</p> <div class="language-as highlighter-rouge"> <div class="highlight"><pre class="highlight"><code>  <span class="nx">sd</span> <span class="nx">x0</span><span class="p">,</span> <span class="mi">0</span><span class="p">(</span><span class="nx">x20</span><span class="p">)</span>           <span class="c1">// free lock</span>
</code></pre></div> </div> <p>x12 中始终为 1。若 x20 为 1（表示锁住状态）则会一直在二三行之间循环，也就是指令被锁在这里了。如果要解锁则将 x20 设为 0（表示解锁状态），此时能顺利通过第三行。</p> <p>通过第三行后，再次尝试对锁复位为 1。若复位成功，x11 为 0，通过第五行，离开本部分指令；如果复位失败，x11 不为 0，说明二四行之间可能发生了 x20 被其他处理器覆写的情况，说明锁还不能松（其它进程在进行），需要回到 again 处重新循环上锁。</p> </li> </ul> </li> <li> <p>Translating and starting a program (程序的编写和执行步骤)</p> <p><img src="/assets/img/blog_post/co/cod-50.png" alt="cod-50" width="50%"></p> <ul> <li> <p>关于 obj 文件</p> <p>object 文件由六部分构成：</p> <ul> <li> <strong>Header</strong>: described contents of object module</li> <li> <strong>Text segment</strong>: translated instructions</li> <li> <strong>Static data segment</strong>: data allocated for the life of the program</li> <li> <strong>Relocation info</strong>: for contents that depend on absolute location of loaded program</li> <li> <strong>Symbol table</strong>: global definitions and external refs</li> <li> <strong>Debug info</strong>: for associating with source code</li> </ul> <p>一个例子如下，其中具有 A / B 两个程序的 obj 文件：</p> <p><img src="/assets/img/blog_post/co/cod-51.png" alt="cod-51" width="50%"></p> <p>将其 Link 之后，生成 Executable 文件如下：</p> <p><img src="/assets/img/blog_post/co/cod-52.png" alt="cod-52" width="50%"></p> </li> <li> <p>关于 Dynamic Linking &amp; Lazy Linkage</p> <p><img src="/assets/img/blog_post/co/cod-53.png" alt="cod-53" width="50%"></p> <p>可以理解为，我在某个程序里调用了一个库函数 F，但实际上 F 的内容并没有被写入 Text 段，而是在其他位置。为了调用时跳转到该位置，我需要先在 Memory Data（记为 MD）中找到 DLL（动态链接库）的位置，然后跳过去；而后 DLL 会告诉我（为我分配）F 的准确位置，然后我再跳一次。是为 Dynamic Linking。</p> <p>第二次调用库函数 F 时，MD 就已经存放了我要的 F 的位置了，直接就可以跳过去。是为 Lazy Linkage。</p> </li> </ul> </li> <li> <p>A C Sort Example To Put it All Together</p> <p>见讲义。一个主要思想是，把 C 转化成汇编语言的范式：</p> <p>Step 1. Allocate registers to program variables</p> <p>Step 2. Produce code for the body of the procedures</p> <p>Step 3. Preserve registers across the procedures invocation</p> </li> </ol> </div> </article> <br> <hr> <br> <ul class="list-disc pl-8"></ul> <h2 class="text-3xl font-semibold mb-4 mt-12">Enjoy Reading This Article?</h2> <p class="mb-2">Here are some more articles you might like to read next:</p> <li class="my-2"> <a class="text-pink-700 underline font-semibold hover:text-pink-800" href="/blog/2024/IT-NOTE-2/">Information Theory Note (Part 2 of 2)</a> </li> <li class="my-2"> <a class="text-pink-700 underline font-semibold hover:text-pink-800" href="/blog/2024/IT-NOTE-1/">Information Theory Note (Part 1 of 2)</a> </li> <li class="my-2"> <a class="text-pink-700 underline font-semibold hover:text-pink-800" href="/blog/2024/CO-NOTE-4/">Computer Organization Note (Part 4 of 4)</a> </li> <li class="my-2"> <a class="text-pink-700 underline font-semibold hover:text-pink-800" href="/blog/2024/CO-NOTE-3/">Computer Organization Note (Part 3 of 4)</a> </li> <li class="my-2"> <a class="text-pink-700 underline font-semibold hover:text-pink-800" href="/blog/2024/CO-NOTE-1/">Computer Organization Note (Part 1 of 4)</a> </li> </div> </div> <footer class="fixed-bottom" role="contentinfo"> <div class="container mt-0"> © Copyright 2025 Yuzhuo Tian. Powered by <a href="https://jekyllrb.com/" target="_blank" rel="external nofollow noopener">Jekyll</a> with <a href="https://github.com/alshedivat/al-folio" rel="external nofollow noopener" target="_blank">al-folio</a> theme. Hosted by <a href="https://pages.github.com/" target="_blank" rel="external nofollow noopener">GitHub Pages</a>. Photos from <a href="https://unsplash.com" target="_blank" rel="external nofollow noopener">Unsplash</a>. </div> </footer> <script src="https://cdn.jsdelivr.net/npm/jquery@3.6.0/dist/jquery.min.js" integrity="sha256-/xUj+3OJU5yExlq6GSYGSHk7tPXikynS7ogEvDej/m4=" crossorigin="anonymous"></script> <script src="/assets/js/bootstrap.bundle.min.js"></script> <script src="https://cdn.jsdelivr.net/npm/mdbootstrap@4.20.0/js/mdb.min.js" integrity="sha256-NdbiivsvWt7VYCt6hYNT3h/th9vSTL4EDWeGs5SN3DA=" crossorigin="anonymous"></script> <script defer src="https://cdn.jsdelivr.net/npm/masonry-layout@4.2.2/dist/masonry.pkgd.min.js" integrity="sha256-Nn1q/fx0H7SNLZMQ5Hw5JLaTRZp0yILA/FRexe19VdI=" crossorigin="anonymous"></script> <script defer src="https://cdn.jsdelivr.net/npm/imagesloaded@5.0.0/imagesloaded.pkgd.min.js" integrity="sha256-htrLFfZJ6v5udOG+3kNLINIKh2gvoKqwEhHYfTTMICc=" crossorigin="anonymous"></script> <script defer src="/assets/js/masonry.js?a0db7e5d5c70cc3252b3138b0c91dcaf" type="text/javascript"></script> <script defer src="https://cdn.jsdelivr.net/npm/medium-zoom@1.1.0/dist/medium-zoom.min.js" integrity="sha256-ZgMyDAIYDYGxbcpJcfUnYwNevG/xi9OHKaR/8GK+jWc=" crossorigin="anonymous"></script> <script defer src="/assets/js/zoom.js?85ddb88934d28b74e78031fd54cf8308"></script> <script src="/assets/js/no_defer.js?2781658a0a2b13ed609542042a859126"></script> <script defer src="/assets/js/common.js?e0514a05c5c95ac1a93a8dfd5249b92e"></script> <script defer src="/assets/js/copy_code.js?c8a01c11a92744d44b093fc3bda915df" type="text/javascript"></script> <script defer src="/assets/js/jupyter_new_tab.js?d9f17b6adc2311cbabd747f4538bb15f"></script> <script async src="https://d1bxh8uas1mnw7.cloudfront.net/assets/embed.js"></script> <script async src="https://badge.dimensions.ai/badge.js"></script> <script defer type="text/javascript" id="MathJax-script" src="https://cdn.jsdelivr.net/npm/mathjax@3.2.2/es5/tex-mml-chtml.js" integrity="sha256-MASABpB4tYktI2Oitl4t+78w/lyA+D7b/s9GEP0JOGI=" crossorigin="anonymous"></script> <script src="/assets/js/mathjax-setup.js?a5bb4e6a542c546dd929b24b8b236dfd"></script> <script defer src="https://cdnjs.cloudflare.com/polyfill/v3/polyfill.min.js?features=es6" crossorigin="anonymous"></script> <script defer src="/assets/js/progress-bar.js?2f30e0e6801ea8f5036fa66e1ab0a71a" type="text/javascript"></script> <script src="/assets/js/vanilla-back-to-top.min.js?f40d453793ff4f64e238e420181a1d17"></script> <script>
    addBackToTop();
  </script> <script type="module" src="/assets/js/search/ninja-keys.min.js?a3446f084dcaecc5f75aa1757d087dcf"></script> <ninja-keys hidebreadcrumbs noautoloadmdicons placeholder="Type to start searching"></ninja-keys> <script src="/assets/js/search-setup.js?6c304f7b1992d4b60f7a07956e52f04a"></script> <script src="/assets/js/search-data.js"></script> <script src="/assets/js/shortcut-key.js?6f508d74becd347268a7f822bca7309d"></script> </body> </html>