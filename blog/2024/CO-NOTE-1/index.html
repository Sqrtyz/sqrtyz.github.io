<!DOCTYPE html> <html lang="en"> <head> <meta http-equiv="Content-Type" content="text/html; charset=UTF-8"> <meta charset="utf-8"> <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no"> <meta http-equiv="X-UA-Compatible" content="IE=edge"> <title> Computer Organization Note (Part 1 of 4) | Yuzhuo Tian </title> <meta name="author" content="Yuzhuo Tian"> <meta name="description" content="Contains content about CO introduction and arithmetic knowledge."> <meta name="keywords" content="jekyll, jekyll-theme, academic-website, portfolio-website"> <link rel="stylesheet" href="/assets/css/bootstrap.min.css?a4b3f509e79c54a512b890d73235ef04"> <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/mdbootstrap@4.20.0/css/mdb.min.css" integrity="sha256-jpjYvU3G3N6nrrBwXJoVEYI/0zw8htfFnhT9ljN3JJw=" crossorigin="anonymous"> <link defer rel="stylesheet" href="/assets/css/academicons.min.css?f0b7046b84e425c55f3463ac249818f5"> <link defer rel="stylesheet" href="/assets/css/scholar-icons.css?62b2ac103a88034e6882a5be5f3e2772"> <link defer rel="stylesheet" type="text/css" href="https://fonts.googleapis.com/css?family=Roboto:300,400,500,700|Roboto+Slab:100,300,400,500,700|Material+Icons&amp;display=swap"> <link defer rel="stylesheet" href="/assets/css/jekyll-pygments-themes-github.css?591dab5a4e56573bf4ef7fd332894c99" media="" id="highlight_theme_light"> <link rel="shortcut icon" href="/assets/img/favicon.ico?f566e11424fb8bc11d484dac03de3f7f"> <link rel="stylesheet" href="/assets/css/main.css?d41d8cd98f00b204e9800998ecf8427e"> <link rel="canonical" href="https://sqrtyz.github.io/blog/2024/CO-NOTE-1/"> <script src="/assets/js/theme.js?a81d82887dd692e91686b43de4542f18"></script> <link defer rel="stylesheet" href="/assets/css/jekyll-pygments-themes-native.css?5847e5ed4a4568527aa6cfab446049ca" media="none" id="highlight_theme_dark"> <script>
    initTheme();
  </script> </head> <body class="fixed-top-nav "> <header> <nav id="navbar" class="navbar navbar-light navbar-expand-sm fixed-top" role="navigation"> <div class="container"> <a class="navbar-brand title font-weight-lighter" href="/"> <span class="font-weight-bold">Yuzhuo</span> Tian </a> <button class="navbar-toggler collapsed ml-auto" type="button" data-toggle="collapse" data-target="#navbarNav" aria-controls="navbarNav" aria-expanded="false" aria-label="Toggle navigation"> <span class="sr-only">Toggle navigation</span> <span class="icon-bar top-bar"></span> <span class="icon-bar middle-bar"></span> <span class="icon-bar bottom-bar"></span> </button> <div class="collapse navbar-collapse text-right" id="navbarNav"> <ul class="navbar-nav ml-auto flex-nowrap"> <li class="nav-item "> <a class="nav-link" href="/">about </a> </li> <li class="nav-item active"> <a class="nav-link" href="/blog/">blog </a> </li> <li class="nav-item "> <a class="nav-link" href="/publications/">publications </a> </li> <li class="nav-item "> <a class="nav-link" href="/cv/">cv </a> </li> <li class="nav-item"> <button id="search-toggle" title="Search" onclick="openSearchModal()"> <span class="nav-link">ctrl k <i class="ti ti-search"></i></span> </button> </li> <li class="toggle-container"> <button id="light-toggle" title="Change theme"> <i class="ti ti-sun-moon" id="light-toggle-system"></i> <i class="ti ti-moon-filled" id="light-toggle-dark"></i> <i class="ti ti-sun-filled" id="light-toggle-light"></i> </button> </li> </ul> </div> </div> </nav> <progress id="progress" value="0"> <div class="progress-container"> <span class="progress-bar"></span> </div> </progress> </header> <div class="container mt-5" role="main"> <div class="post"> <header class="post-header"> <h1 class="post-title">Computer Organization Note (Part 1 of 4)</h1> <p class="post-meta"> Created on January 01, 2024 </p> <p class="post-tags"> <a href="/blog/2024"> <i class="fa-solid fa-calendar fa-sm"></i> 2024 </a>   ·   <a href="/blog/tag/hardware"> <i class="fa-solid fa-hashtag fa-sm"></i> Hardware</a>   ·   <a href="/blog/category/course"> <i class="fa-solid fa-tag fa-sm"></i> Course</a>   <a href="/blog/category/notes"> <i class="fa-solid fa-tag fa-sm"></i> Notes</a> </p> </header> <article class="post-content"> <div id="markdown-content"> <blockquote> <p>Part I 包含第一、三章，涉及导论内容和计算机运算问题。</p> </blockquote> <h2 id="chapter-1-computer-abstractions-and-technology">Chapter 1. Computer Abstractions and Technology</h2> <h3 id="history--development">History &amp; Development</h3> <ul> <li>第一代：电子管 / 真空管</li> <li>第二代：晶体管</li> <li>第三代：集成电路</li> <li>第四代：微处理器</li> </ul> <h3 id="computer-organization">Computer Organization</h3> <ul> <li> <p>Hardware</p> <p><img src="/assets/img/blog_post/co/cod-3.png" alt="cod-3">{width=”50%”}</p> <p>Datapath 可以理解为一条「流水线」。</p> </li> <li> <p>Software</p> <p><img src="/assets/img/blog_post/co/cod-4.png" alt="cod-4"></p> </li> </ul> <h3 id="指令集isa">指令集（ISA）</h3> <ul> <li> <p><strong>ISA</strong>: The interface between hardware and lowest-level software.</p> <p>指令集筑起了「硬件」与「软件」之间的桥梁。硬件生产厂商只需要支持指令集中的特定操作，而软件厂商只需要借助这些基本指令集来开发软件。</p> </li> </ul> <h3 id="cpu-time-calculation">CPU Time Calculation</h3> <ul> <li> <p>Basic Concepts</p> <ul> <li> <p><strong>[CONCEPT] Response Time</strong> (Execution Time)：响应时间，how long it takes to do a task.</p> </li> <li> <p><strong>[CONCEPT] Throughput</strong> (Bandwidth)：吞吐率，total work done per unit time.</p> </li> </ul> </li> <li> <p>Performance Measurement</p> <p>假设 X 比 Y 快 $n$ 倍，那么 $\frac{\text{Execution Time}_Y}{\text{Execution Time}_X}=n$。</p> </li> <li> <p>Clock</p> <p><img src="/assets/img/blog_post/co/cod-5.png" alt="cod-5"></p> <ul> <li> <p><strong>[CONCEPT] Clock Cycle Time</strong>: duration of a clock cycle.</p> </li> <li> <p><strong>[CONCEPT] Clock Rate</strong>: cycles per second，与 Clock period 成倒数。</p> </li> <li> <p>CPU Time = CPU Clock Cycles × Clock Cycle Time = CPU Clock Cycles / Clock Rate</p> </li> </ul> </li> <li> <p>Considering Instructions</p> <ul> <li> <p><strong>[CONCEPT] CPI</strong>: Cycles Per Instruction. <strong>CPI 的值由 CPU 本身决定，同时也受到指令种类的影响</strong>（例如，加法和乘法所需要的 Cycles 肯定不一样）。</p> </li> <li> <p>Clock Cycles = Instruction Count × CPI</p> <p>CPU Time = Instruction Count × CPI × Clock Cycle Time = Instruction Count × CPI / Clock Rate</p> </li> <li> <p>考虑不同 Instruction Type 对 CPI 的影响……</p> <p>$\text{Clock Cycles} = \sum\limits_{i=1}^n (\text{CPI}_i \times \text{Instruction Count}_i)$</p> <p>加权平均 CPI（global CPI）：字面意思。</p> </li> </ul> </li> <li> <p>Power Spent</p> <p>$\text{Power} = \text{Capacitive load}^2 \times \text{Voltage} \times \text{Frequency}$</p> </li> <li> <p>习题演示</p> <p><img src="/assets/img/blog_post/co/cod-6.png" alt="cod-6"></p> </li> </ul> <h3 id="some-pitfalls--fallacies">Some Pitfalls / Fallacies</h3> <ul> <li> <p>Amdahl’s Law 提升局部不一定能提升总体</p> \[T_{imporved} = \frac{T_{affected}}{\text{improvement factor}} + T_{unaffected}\] <p>其中 $T_{imporved}$ 表示提升后的总用时。$\text{improvement factor}$ 表示受影响的提升方面的提升比例。此公式意在说明，对于某种提升，只有 affected 的部分会变快，unaffected 的部分怎么都不会变快。</p> <p>例如，一个程序需要执行 80s 的乘法和 20s 的除法。无论乘法提升了多少，我们都无法把总时间提升 5 倍。</p> </li> <li> <p>Low Power at Idle 功耗和负载不成正比</p> <p>对于 i7 power benchmark，100% 负载下的功耗为 258W，50% 负载下为 170W，10% 负载下为 121W。也就是说，一味降低 CPU 的负载不一定能起到节能的效果。</p> </li> <li> <p>MIPS as a Performance Metric? MIPS 是否能作为衡量 CPU 运行速度的参数？</p> <p>MIPS: Millions of Instructions Per Second</p> \[\text{MIPS} = \frac{\text{Clock Rate}}{\text{CPI} \times 10^6}\] <p>之前提及，CPI 除了受 CPU 本身的影响，也受到 CPI 种类等因素的影响。不同电脑的指令集架构不同，进而导致 CPI 不同；同时，不同指令的 CPI 也不一样。所以 MIPS 并非一个只和 CPU 本身有关的量。所以用 MIPS 来衡量 CPU 的运行速度是不合理的。</p> </li> </ul> <h3 id="eight-great-ideas">Eight Great Ideas</h3> <ul> <li> <p>Design for Moore’s Law (设计紧跟摩尔定律)</p> </li> <li> <p>Use Abstraction to Simplify Design (采用抽象简化设计)</p> </li> <li> <p>Make the Common Case Fast (加速大概率事件)</p> </li> <li> <p>Performance via Parallelism (通过并行提高性能)</p> </li> <li> <p>Performance via Pipelining (通过流水线提高性能)</p> </li> <li> <p>Performance via Prediction (通过预测提高性能)</p> </li> <li> <p>Hierarchy of Memories (存储器层次)</p> </li> <li> <p>Dependability via Redundancy (通过冗余提高可靠性)</p> </li> </ul> <hr> <ul> <li> <p>Some illustrations:</p> <p>Use Abstraction to Simplify Design:</p> <p><img src="/assets/img/blog_post/co/cod-1.png" alt="cod-1"></p> <p>Performance via Pipelining:</p> <p><img src="/assets/img/blog_post/co/cod-2.png" alt="cod-2"></p> </li> </ul> <h2 id="chapter-3-arithmetic-for-computer">Chapter 3. Arithmetic for Computer</h2> <h3 id="signed-numbers-representations">Signed Numbers Representations</h3> <table> <thead> <tr> <th>Binary</th> <th>Signed Magnitude</th> <th>2’s Complement</th> </tr> </thead> <tbody> <tr> <td>000</td> <td>+0</td> <td>+0</td> </tr> <tr> <td>001</td> <td>+1</td> <td>+1</td> </tr> <tr> <td>010</td> <td>+2</td> <td>+2</td> </tr> <tr> <td>011</td> <td>+3</td> <td>+3</td> </tr> <tr> <td>100</td> <td>-0</td> <td>-4</td> </tr> <tr> <td>101</td> <td>-1</td> <td>-3</td> </tr> <tr> <td>110</td> <td>-2</td> <td>-2</td> </tr> <tr> <td>111</td> <td>-3</td> <td>-1</td> </tr> </tbody> </table> <p>一般采取补码的表示方式。</p> <h3 id="addition-and-subtraction">Addition and Subtraction</h3> <p>减法可以改成加补码。这样加和减都统一成了加法。</p> <p>加减法都可能产生 overflow。例如：</p> <p><img src="/assets/img/blog_post/co/cod-7.png" alt="cod-7"></p> <p>overflow 的判定遵循下表：</p> <p><img src="/assets/img/blog_post/co/cod-8.png" alt="cod-8"></p> <ul> <li> <p>此处的 overflow 专指「溢出导致错误的计算结果」。例如 $(-1)+(-1)=(-2)$ 我们不认为发生了 overflow。</p> </li> <li> <p>只有以上四种 A, B 组合才可能产生 overflow。例如一个正数加一个负数是不可能产生 overflow 的。</p> </li> <li> <p>Result overflow 括号中的两个数分别表示「溢出位」和「最高位」。例如 $7+7=(0111)_2+(0111)_2=(1110)_2=-2$，其溢出位（第 4 位）为 $0$，最高位（第 3 位）为 $1$，属于表中的第一行情况。</p> </li> <li> <p>可以看到「溢出位」和「最高位」在溢出情况下总是相反的，这意味着我们可以使用 XOR 门进行判定。</p> </li> </ul> <h3 id="alu">ALU</h3> <p>考虑建立具有如下功能的 ALU：</p> <p><img src="/assets/img/blog_post/co/cod-9.png" alt="cod-9"></p> <p>其中 srl 表示 shift right logical，Zero 位宽为 1，输出 1 当且仅当 Result 为 0。</p> <ol> <li> <p>And 与 Or</p> <p><img src="/assets/img/blog_post/co/cod-10.png" alt="cod-10"></p> </li> <li> <p>Add</p> <p>全加器，$S=a \oplus b \oplus C_{in}, \ C_{out}=ab+aC_{in}+bC_{in}$。</p> <p><img src="/assets/img/blog_post/co/cod-11.png" alt="cod-11"></p> </li> <li> <p>Sub</p> <p>减法就是加上补码。考虑 And / Or / Add / Sub 的 ALU 设计如下：</p> <p><img src="/assets/img/blog_post/co/cod-12.png" alt="cod-12"></p> </li> <li> <p>Set on less than (Comparison)</p> <p>用于比较输入项 $a,b$ 的大小，如果 $a &lt; b$，那么输出 $1$，反之输出 $0$。</p> <p>实现方法是执行减法运算，看最高位（符号位）是否为 $1$ 即可。</p> </li> </ol> <p>考虑 And / Or / Add / Sub / Set on less than 的 ALU 设计如下：</p> <p><img src="/assets/img/blog_post/co/cod-13.png" alt="cod-13"></p> <p>其中 MSB 的设计有略微不同（加入了溢出检测模块，输出 Set 和 Overflow 信号）</p> <p><img src="/assets/img/blog_post/co/cod-14.png" alt="cod-14"></p> <p><strong>最后我们考虑建立整个 ALU。</strong></p> <p><img src="/assets/img/blog_post/co/cod-15.png" alt="cod-15"></p> <p>注意到 MSB 的 Set 连到了 LSB 的 Less 输入，用于执行 Comparison 运算；非 LSB 的 Less 输入均为零。</p> <h3 id="fast-adder">Fast Adder</h3> <p><strong>Carry Lookahead Adder (CLA) 加速运算</strong>：本质上是把行波加法给「压缩」了。但受到 fan-in of gate 的影响，只有分组「压缩」。</p> <p>此部分数逻已经学过，在此不再赘述。</p> <h3 id="multiplication">Multiplication</h3> <p><strong>名词</strong>：被乘数（multiplicand），乘数（multiplier），积（product）。</p> <ol> <li> <p>Multiplier Ver 1</p> <p>Look at current bit position.</p> <ul> <li> <p>if multiplier is 1, then add multiplicand.</p> </li> <li> <p>Otherwise add 0.</p> </li> <li> <p>Shift multiplicand left by 1 bit.</p> </li> </ul> <p><img src="/assets/img/blog_post/co/cod-16.png" alt="cod-16"></p> <p>其实就是模拟的竖式乘法。对于两个 64 bits 的整数相乘，需要 128 bits 的寄存器存储积，同时也需要一个 128 bits 的 ALU 来执行加法。</p> </li> <li> <p>Multiplier Ver 2</p> <p>在第一版乘法器的基础上，第二版将「左移 multiplicand」改成了「右移 product」来减小 ALU 的开销。原理图和举例图如下。</p> <p><img src="/assets/img/blog_post/co/cod-17.png" alt="cod-17"></p> <p><img src="/assets/img/blog_post/co/cod-18.png" alt="cod-18"></p> <p>注意每一次是将 multiplicand 加到 product 左边的 64 位，而后进行不断的右移。对于两个 64 bits 的整数相乘，需要 128 bits 的寄存器存储积，但只需要一个 64 bits 的 ALU 来执行加法。</p> </li> <li> <p>Multiplier Ver 3</p> <p>基于第二版乘法器进行了一点小优化。回顾我们使用的 128 位的存储积的 reg，刚开始 reg 的右 64 位是空的，这意味着说我们可以将其用于存储 multiplier。并且随着后续 product 和 multiplier 的右移，两者也不会产生空间上的冲突。</p> <p><img src="/assets/img/blog_post/co/cod-19.png" alt="cod-19"></p> <p><img src="/assets/img/blog_post/co/cod-20.png" alt="cod-20"></p> <p>红色部分存储的是 multiplier。可以看到 multiplier 和 product 共用一个 reg。</p> </li> <li> <p>有符号乘法</p> <p>考虑有符号整数乘法。一种基本的方法是，符号和绝对值分开考虑。符号位直接进行 XOR，随后将 MSB 设为 0（去除符号位）并执行无符号乘法，最后将符号和绝对值的积合并即可。</p> <p>此外还有一种方法：<strong>Booth’s Algorithm.</strong></p> </li> <li> <p>Booth 算法</p> <p>Booth 算法的执行基于第三版乘法器，但是做了一定的优化。<strong>Booth 算法在加速了乘法的同时，也使得有符号的乘法运算更加统一（即不需要传统方法的分类讨论）。</strong></p> <p>考虑被乘数为 $y$，乘数为 $10111100$。按照第三版乘法器的做法，会执行 $8$ 次 shift 操作和 $5$ 次 add 操作。如果我们将 $10111100$ 改写为 $2^7+2^6-2^2$，则只需要执行 $8$ 次 shift 操作和 $3$ 次 add/sub 操作（在此我们假设 shift 速度快于 add/sub）。</p> <ul> <li> <p>流程</p> <p>每次考察乘数的 0 位和 -1 位（此处 -1 位是人为补足的，初始为 0）。并按照以下表格执行操作：</p> <table> <thead> <tr> <th>bit(0) and bit(-1)</th> <th>Operations</th> </tr> </thead> <tbody> <tr> <td>$10$</td> <td>Subtract multiplicand from left half</td> </tr> <tr> <td>$11$</td> <td>No arithmetic operations, just shift right</td> </tr> <tr> <td>$01$</td> <td>Add multiplicand to left half</td> </tr> <tr> <td>$00$</td> <td>No arithmetic operations, just shift right</td> </tr> </tbody> </table> <p>此处依然是按照第三版乘法器那样将 product, multiplier 放在一起存储，且每次 shift right 都是将两者一起右移。</p> <p><strong>同时：每次右移最高位的不足不再是无脑补零，而是和原最高位一样补（即每次右移保持符号位不变）。</strong></p> </li> <li> <p>例子</p> <p><img src="/assets/img/blog_post/co/cod-22.png" alt="cod-22"></p> <p>注意执行的轮次数和乘数的 bit 数一致。第一轮是 10，第二轮是 01，第三轮是 10，第四轮是 11，第五轮（本来是 11）无需执行。</p> </li> <li> <p>一些粗浅的理解</p> <p><strong>关于加减法：</strong> 遇 10 则减，遇 01 则加其实比较好颅内理解。00 和 11 不干事都是为了「把锅甩给后面的高位」。</p> <p><strong>关于右移最高位补足、为何不进行第 5 轮：</strong> 首先考虑另外一个问题，为什么常规无符号乘法无法做有符号的乘法。例如，$0010 \times 1101 = 00011010$，正负得正，显然是有问题的。</p> <p>实际上问题出在位数不足。补齐后 $00000010 \times 11111101 = 11111010$ （取低 8 位）就没有问题了。</p> <p>然而把四位乘法转化为 8 bits × 8 bits 做是有点亏的，同时注意到有很多连续的 1 似乎加法也会很多。所以使用 Booth’s Algorithm。</p> <p>解答这个问题可能需要考虑 8 bits × 8 bits 的本原做法。比如在 iteration 1 中要减去被乘数，在算法中体现的是 +1110，然而实际上应该是 +11111110。这样在整体右移一位之后最高位确实应该为 1。</p> <p>为何不进行最后一轮似乎也和这个有关。像比如上图的例子，按理说最后应该再做一个 left half 的 +0010 才对，然而当我们把乘数 $1101$ 补全为 $1111 \ 1101$ 后，发现实际上这个 +0010 应该在 iter 9 执行，实际上表现出来的就是溢出了 8 bits 的范围。</p> </li> </ul> </li> </ol> <h3 id="division">Division</h3> <p><strong>名词</strong>：被除数（dividend），除数（divisor），商（quotient），余数（remainder）。</p> <ol> <li> <p>Division Introduction</p> <ul> <li> <p>除数为 0 一般交由软件判断。</p> </li> <li> <p>有符号除法一般将符号和绝对值分开讨论。</p> </li> </ul> </li> <li> <p>Division Ver 1</p> <p><img src="/assets/img/blog_post/co/cod-23.png" alt="cod-23"></p> <p>假设 dividend 和 divisor 都是 64 位的。</p> <ul> <li> <p>首先将实际的 divisor 放到高 64 位（低 64 位为零）。remainder 初始设置为 dividend。</p> </li> <li> <p>接下来每次拿 remainder 减去 divisor。若减后 remainder 大于等于 0，则将 quotient 左移并将 LSB 设为 1；若减后 remainder 小于 0，则恢复原值（把 divisor 加回去），同时也将 quotient 左移。</p> </li> <li> <p>将 divisor 右移一位。重复 65 次。</p> </li> </ul> <p>其实就是模拟的竖式除法。一个示例如下。</p> <p><img src="/assets/img/blog_post/co/cod-24.png" alt="cod-24"></p> </li> <li> <p>Division Ver 3</p> <p>和之前的 Multiplier V3 一致的思路：将 remainder 和 quotient 放在一个 reg 中存放。</p> <p><img src="/assets/img/blog_post/co/cod-25.png" alt="cod-25"></p> <p><img src="/assets/img/blog_post/co/cod-26.png" alt="cod-26"></p> <p>注意初始的时候就可以将 remainder 左移一位（对应 iter0，因为第一次必然失败）。最后 reg 中的 left half 即为 remainder，right half 即为 quotient。</p> </li> </ol> <h3 id="float">Float</h3> <ul> <li> <p>浮点数的存储与定义</p> <p>浮点数的存储分为三部分。</p> <ul> <li>float：符号位 $S$ (1bit)，指数位 $E$ (8bits)，系数位 $F$ (23bits)。</li> <li>double：符号位 $S$ (1bit)，指数位 $E$ (11bits)，系数位 $F$ (52bits)。</li> </ul> <p>其意义为二进制下的科学计数法表示：$(-1)^S \times 1.F \times 2^{E+bias}$。</p> <p>实际使用时指数位 $E$ 会有偏差 $bias$，这是为了处理 $E$ 可能为负的情况。对于 float，$E$ 存储值比实际值大 $bias=127$；对于 double，$E$ 存储值比实际值大 $bias=1023$。</p> <p>特别规定：</p> <ul> <li>当 $E=111…11, \ F=000…00$，表示此浮点数为无穷。</li> <li>当 $E=111…11, \ F \neq 000…00$，表示此浮点数为 NaN。</li> </ul> </li> <li> <p>浮点数加法</p> <p>算法流程与示例：</p> <ol> <li> <p>比较两数的指数位，确定大小关系并把指数位较小的通过 $F$ 右移（小数点则向左移动）使得两操作数的指数位 $E$ 一致。</p> </li> <li> <p>将 $F$ 相加。</p> </li> <li> <p>归一化（比如加法之后产生了进位，那么 $E$ 应当加一，$F$ 则右移）。</p> </li> <li> <p>Rounding（比如四舍五入）</p> </li> <li> <p>再次归一化（例如 9.99 round 后变为 10.00，此时需要再次归一化，当然这只是一个十进制的例子）</p> </li> </ol> <p><img src="/assets/img/blog_post/co/cod-27.png" alt="cod-27"></p> <p>逻辑结构图绘制：</p> <p><img src="/assets/img/blog_post/co/cod-28.png" alt="cod-28"></p> </li> <li> <p>浮点数乘法</p> <p>区别主要集中在：</p> <ol> <li>符号位单独处理</li> <li>指数位 $E$ 相加后要减去对应的 $bias$。</li> </ol> <p><img src="/assets/img/blog_post/co/cod-29.png" alt="cod-29"></p> </li> <li> <p>Accurate Arithmetic 浮点数精度问题</p> <p>一些术语：</p> <ul> <li> <p>保留位 (guard bit)：第一个被舍掉的位。</p> </li> <li> <p>近似位 (round bit)：guard bit 的后面一位，亦即第二个被舍掉的位。</p> </li> <li> <p>粘滞位 (sticky bit)：round bit 后面的所有位的 OR 构成 sticky bit。</p> </li> </ul> <p>Rounding 规则如下：</p> <p><img src="/assets/img/blog_post/co/cod-30.png" alt="cod-30"></p> </li> </ul> </div> </article> <br> <hr> <br> <ul class="list-disc pl-8"></ul> <h2 class="text-3xl font-semibold mb-4 mt-12">Enjoy Reading This Article?</h2> <p class="mb-2">Here are some more articles you might like to read next:</p> <li class="my-2"> <a class="text-pink-700 underline font-semibold hover:text-pink-800" href="/blog/2024/CO-NOTE-4/">Computer Organization Note (Part 4 of 4)</a> </li> <li class="my-2"> <a class="text-pink-700 underline font-semibold hover:text-pink-800" href="/blog/2024/CO-NOTE-3/">Computer Organization Note (Part 3 of 4)</a> </li> <li class="my-2"> <a class="text-pink-700 underline font-semibold hover:text-pink-800" href="/blog/2024/CO-NOTE-2/">Computer Organization Note (Part 2 of 4)</a> </li> </div> </div> <footer class="fixed-bottom" role="contentinfo"> <div class="container mt-0"> © Copyright 2025 Yuzhuo Tian. Powered by <a href="https://jekyllrb.com/" target="_blank" rel="external nofollow noopener">Jekyll</a> with <a href="https://github.com/alshedivat/al-folio" rel="external nofollow noopener" target="_blank">al-folio</a> theme. Hosted by <a href="https://pages.github.com/" target="_blank" rel="external nofollow noopener">GitHub Pages</a>. Photos from <a href="https://unsplash.com" target="_blank" rel="external nofollow noopener">Unsplash</a>. </div> </footer> <script src="https://cdn.jsdelivr.net/npm/jquery@3.6.0/dist/jquery.min.js" integrity="sha256-/xUj+3OJU5yExlq6GSYGSHk7tPXikynS7ogEvDej/m4=" crossorigin="anonymous"></script> <script src="/assets/js/bootstrap.bundle.min.js"></script> <script src="https://cdn.jsdelivr.net/npm/mdbootstrap@4.20.0/js/mdb.min.js" integrity="sha256-NdbiivsvWt7VYCt6hYNT3h/th9vSTL4EDWeGs5SN3DA=" crossorigin="anonymous"></script> <script defer src="https://cdn.jsdelivr.net/npm/masonry-layout@4.2.2/dist/masonry.pkgd.min.js" integrity="sha256-Nn1q/fx0H7SNLZMQ5Hw5JLaTRZp0yILA/FRexe19VdI=" crossorigin="anonymous"></script> <script defer src="https://cdn.jsdelivr.net/npm/imagesloaded@5.0.0/imagesloaded.pkgd.min.js" integrity="sha256-htrLFfZJ6v5udOG+3kNLINIKh2gvoKqwEhHYfTTMICc=" crossorigin="anonymous"></script> <script defer src="/assets/js/masonry.js?a0db7e5d5c70cc3252b3138b0c91dcaf" type="text/javascript"></script> <script defer src="https://cdn.jsdelivr.net/npm/medium-zoom@1.1.0/dist/medium-zoom.min.js" integrity="sha256-ZgMyDAIYDYGxbcpJcfUnYwNevG/xi9OHKaR/8GK+jWc=" crossorigin="anonymous"></script> <script defer src="/assets/js/zoom.js?85ddb88934d28b74e78031fd54cf8308"></script> <script src="/assets/js/no_defer.js?2781658a0a2b13ed609542042a859126"></script> <script defer src="/assets/js/common.js?e0514a05c5c95ac1a93a8dfd5249b92e"></script> <script defer src="/assets/js/copy_code.js?c8a01c11a92744d44b093fc3bda915df" type="text/javascript"></script> <script defer src="/assets/js/jupyter_new_tab.js?d9f17b6adc2311cbabd747f4538bb15f"></script> <script async src="https://d1bxh8uas1mnw7.cloudfront.net/assets/embed.js"></script> <script async src="https://badge.dimensions.ai/badge.js"></script> <script defer type="text/javascript" id="MathJax-script" src="https://cdn.jsdelivr.net/npm/mathjax@3.2.2/es5/tex-mml-chtml.js" integrity="sha256-MASABpB4tYktI2Oitl4t+78w/lyA+D7b/s9GEP0JOGI=" crossorigin="anonymous"></script> <script src="/assets/js/mathjax-setup.js?a5bb4e6a542c546dd929b24b8b236dfd"></script> <script defer src="https://cdnjs.cloudflare.com/polyfill/v3/polyfill.min.js?features=es6" crossorigin="anonymous"></script> <script defer src="/assets/js/progress-bar.js?2f30e0e6801ea8f5036fa66e1ab0a71a" type="text/javascript"></script> <script src="/assets/js/vanilla-back-to-top.min.js?f40d453793ff4f64e238e420181a1d17"></script> <script>
    addBackToTop();
  </script> <script type="module" src="/assets/js/search/ninja-keys.min.js?a3446f084dcaecc5f75aa1757d087dcf"></script> <ninja-keys hidebreadcrumbs noautoloadmdicons placeholder="Type to start searching"></ninja-keys> <script src="/assets/js/search-setup.js?6c304f7b1992d4b60f7a07956e52f04a"></script> <script src="/assets/js/search-data.js"></script> <script src="/assets/js/shortcut-key.js?6f508d74becd347268a7f822bca7309d"></script> </body> </html>